--- /home/jtratt/s/Release.NetHack-NetHack-3.6.6_Released/src/options.c	2020-03-08 12:29:31.000000000 -0500
+++ /home/jtratt/s/voice_Nethack_366/src/options.c	2025-02-23 17:34:48.762885289 -0600
@@ -7,6 +7,7 @@
 #include "config.h"
 #include "objclass.h"
 #include "flag.h"
+
 NEARDATA struct flag flags; /* provide linkage */
 #ifdef SYSFLAGS
 NEARDATA struct sysflag sysflags; /* provide linkage */
@@ -19,6 +20,10 @@
 #include <ctype.h>
 #endif
 
+#ifdef VOICE_ENABLED
+#include <regex.h>  /* For regex_t, regcomp, etc. in add_voice_force */
+#endif /* VOICE_ENABLED */
+
 #define BACKWARD_COMPAT
 
 #ifdef DEFAULT_WC_TILED_MAP
@@ -41,6 +46,7 @@
 };
 
 #define PILE_LIMIT_DFLT 5
+#define AUTOSAVE_DFLT -1
 
 static char empty_optstr[] = { '\0' };
 
@@ -238,6 +244,9 @@
     { "use_inverse", &iflags.wc_inverse, FALSE, SET_IN_GAME }, /*WC*/
 #endif
     { "verbose", &flags.verbose, TRUE, SET_IN_GAME },
+#ifdef VOICE_ENABLED
+    { "voice_enabled", &flags.voice_enabled, FALSE, SET_IN_GAME },
+#endif /* VOICE_ENABLED */
 #ifdef TTY_TILES_ESCCODES
     { "vt_tiledata", &iflags.vt_tiledata, FALSE, SET_IN_FILE },
 #else
@@ -275,6 +284,7 @@
     { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
     { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/
     { "altkeyhandler", "alternate key handler", 20, SET_IN_GAME },
+    { "autosave", "quit game after N turns", 20, DISP_IN_GAME },   /*WC*/
 #ifdef BACKWARD_COMPAT
     { "boulder", "deprecated (use S_boulder in sym file instead)", 1,
       SET_IN_GAME },
@@ -433,6 +443,10 @@
     { "videoshades", "gray shades to map to black/gray/white", 32,
       DISP_IN_GAME },
 #endif
+#ifdef VOICE_ENABLED
+    { "voice_command", "command for external voice engine (espeak, gtts, say, etc.)",
+        sizeof flags.voice_command * 2, DISP_IN_GAME },
+#endif /* VOICE_ENABLED */
     { "whatis_coord", "show coordinates when auto-describing cursor position",
       1, SET_IN_GAME },
     { "whatis_filter",
@@ -539,6 +553,23 @@
 static char mapped_menu_op[MAX_MENU_MAPPED_CMDS + 1];
 static short n_menu_mapped = 0;
 
+#ifdef PREADJUST
+/* Stuff for doing starting inventory pre-#adjusts. */
+typedef struct {
+    const char *descr;
+# ifdef STICKY_OBJECTS
+    boolean sticky;
+# endif /* STICKY_OBJECTS */
+    char invlet;
+} preadjust;
+
+static preadjust *preadj_list = 0;
+static int n_preadjust = 0;
+static int preadjust_size = 0;
+#endif /* PREADJUST */
+
+
+
 static boolean initial, from_file;
 
 STATIC_DCL void FDECL(nmcpy, (char *, const char *, int));
@@ -736,8 +767,10 @@
     flags.end_around = 2;
     flags.paranoia_bits = PARANOID_PRAY; /* old prayconfirm=TRUE */
     flags.pile_limit = PILE_LIMIT_DFLT;  /* 5 */
+    iflags.autosave = -1;                /* Disabled by default */
     flags.runmode = RUN_LEAP;
     iflags.msg_history = 20;
+    flags.voice_command[0] = '\0';  // Set to empty string by default
     /* msg_window has conflicting defaults for multi-interface binary */
 #ifdef TTY_GRAPHICS
     iflags.prevmsg_window = 's';
@@ -2005,7 +2038,7 @@
     return FALSE;
 }
 
-boolean
+boolean 
 parseoptions(opts, tinitial, tfrom_file)
 register char *opts;
 boolean tinitial, tfrom_file;
@@ -2674,6 +2707,68 @@
         return retval;
     }
 
+#ifdef VOICE_ENABLED
+    fullname = "VOICE_EXCEPTION"; /* suppress voice output for pattern */
+    if (match_optname(opts, fullname, 13, TRUE)) {
+        if (duplicate)
+            complain_about_duplicate(opts, 1);
+        if (negated) {
+            bad_negation(fullname, FALSE);
+            return FALSE;
+        } else if ((op = string_for_opt(opts, FALSE)) != empty_optstr) {
+            if (add_voice_exception(op) < 0) {
+                config_error_add("Failed to add VOICE_EXCEPTION '%s'", op);
+                return FALSE;
+            }
+        } else {
+            return FALSE;
+        }
+        return retval;
+    }
+
+    fullname = "VOICE_FORCE"; /* force voice output for pattern */
+    if (match_optname(opts, fullname, 11, TRUE)) {
+        if (duplicate)
+            complain_about_duplicate(opts, 1);
+        if (negated) {
+            bad_negation(fullname, FALSE);
+            return FALSE;
+        } else if ((op = string_for_opt(opts, FALSE)) != empty_optstr) {
+            int result = add_voice_force(op);
+            if (result < 0) {
+                config_error_add("Could not compile VOICE_FORCE regex: '%s'", op);
+                return FALSE;
+            } else if (!initial && !tfrom_file) {
+                ;//config_error_add("Successfully compiled VOICE_FORCE: '%s'", op); /* Optional debug */
+                }
+        } else {
+            return FALSE;
+        }
+        return retval;
+    }
+
+    fullname = "voice_command";
+    if (match_optname(opts, fullname, 12, TRUE)) {
+        if (duplicate)
+            complain_about_duplicate(opts, 1);
+        op = string_for_opt(opts, negated);
+        if ((negated && op == empty_optstr) || (!negated && op != empty_optstr)) {
+            if (negated) {
+                flags.voice_command[0] = '\0';  // Reset to empty if negated
+            } else {
+                strncpy(flags.voice_command, op, sizeof(flags.voice_command) - 1);
+                flags.voice_command[sizeof(flags.voice_command) - 1] = '\0'; // Ensure null termination
+            }
+        } else if (negated) {
+            bad_negation(fullname, TRUE);
+            return FALSE;
+        } else { // op == empty_optstr
+            flags.voice_command[0] = '\0';  // Set to empty if no value provided
+        }
+        return retval;
+    }
+#endif /* VOICE_ENABLED */
+
     fullname = "whatis_coord";
     if (match_optname(opts, fullname, 8, TRUE)) {
         if (duplicate)
@@ -3105,6 +3200,30 @@
         return retval;
     }
 
+    /* autosave: play game for N turns, then automatically save-and-quit
+       when safe opportunity presents itself (-1 = no autosave) */
+    fullname = "autosave";
+    if (match_optname(opts, fullname, 5, TRUE)) {
+        if (duplicate)
+            complain_about_duplicate(opts, 1);
+        op = string_for_opt(opts, negated);
+        if ((negated && !op) || (!negated && op))
+            iflags.autosave = negated ? -1 : atoi(op);
+        else if (negated) {
+            bad_negation(fullname, TRUE);
+            return FALSE;
+        } else /* !op */
+            iflags.autosave = AUTOSAVE_DFLT;
+        /* sanity check */
+        if (iflags.autosave < -1)
+            iflags.autosave = AUTOSAVE_DFLT;
+        else if (iflags.autosave == 0) {
+            config_error_add("Autosave should be non-zero, assuming off");
+            iflags.autosave = AUTOSAVE_DFLT;
+        }
+        return retval;
+    }
+
     /* play mode: normal, explore/discovery, or debug/wizard */
     fullname = "playmode";
     if (match_optname(opts, fullname, 4, TRUE)) {
@@ -4123,62 +4242,62 @@
                 if (iflags.use_color)
                     need_redraw = TRUE; /* darkroom refresh */
             } else if (boolopt[i].addr == &flags.showrace
-                       || boolopt[i].addr == &iflags.use_inverse
-                       || boolopt[i].addr == &iflags.hilite_pile
-                       || boolopt[i].addr == &iflags.perm_invent
+                   || boolopt[i].addr == &iflags.use_inverse
+                   || boolopt[i].addr == &iflags.hilite_pile
+                   || boolopt[i].addr == &iflags.perm_invent
 #ifdef CURSES_GRAPHICS
-                       || boolopt[i].addr == &iflags.cursesgraphics
+                   || boolopt[i].addr == &iflags.cursesgraphics
 #endif
-                       || boolopt[i].addr == &iflags.wc_ascii_map
-                       || boolopt[i].addr == &iflags.wc_tiled_map) {
-                need_redraw = TRUE;
-            } else if (boolopt[i].addr == &iflags.hilite_pet) {
+                   || boolopt[i].addr == &iflags.wc_ascii_map
+                   || boolopt[i].addr == &iflags.wc_tiled_map) {
+            need_redraw = TRUE;
+        } else if (boolopt[i].addr == &iflags.hilite_pet) {
 #ifdef CURSES_GRAPHICS
-                if (WINDOWPORT("curses")) {
-                    /* if we're enabling hilite_pet and petattr isn't set,
-                       set it to Inverse; if we're disabling, leave petattr
-                       alone so that re-enabling will get current value back */
-                    if (iflags.hilite_pet && !iflags.wc2_petattr)
-                        iflags.wc2_petattr = curses_read_attrs("I");
-                }
+            if (WINDOWPORT("curses")) {
+                /* if we're enabling hilite_pet and petattr isn't set,
+                   set it to Inverse; if we're disabling, leave petattr
+                   alone so that re-enabling will get current value back */
+                if (iflags.hilite_pet && !iflags.wc2_petattr)
+                    iflags.wc2_petattr = curses_read_attrs("I");
+            }
 #endif
+            need_redraw = TRUE;
+        } else if (boolopt[i].addr == &iflags.wc2_hitpointbar) {
+            if (VIA_WINDOWPORT()) {
+                /* [is reassessment really needed here?] */
+                status_initialize(REASSESS_ONLY);
                 need_redraw = TRUE;
-            } else if (boolopt[i].addr == &iflags.wc2_hitpointbar) {
-                if (VIA_WINDOWPORT()) {
-                    /* [is reassessment really needed here?] */
-                    status_initialize(REASSESS_ONLY);
-                    need_redraw = TRUE;
-                }
+            }
 #ifdef TEXTCOLOR
-            } else if (boolopt[i].addr == &iflags.use_color) {
-                need_redraw = TRUE;
+        } else if (boolopt[i].addr == &iflags.use_color) {
+            need_redraw = TRUE;
 #ifdef TOS
-                if (iflags.BIOS) {
-                    if (colors_changed)
-                        restore_colors();
-                    else
-                        set_colors();
-                }
+            if (iflags.BIOS) {
+                if (colors_changed)
+                    restore_colors();
+                else
+                    set_colors();
+            }
 #endif
-            } else if (boolopt[i].addr == &iflags.use_menu_color
-                       || boolopt[i].addr == &iflags.wc2_guicolor) {
-                update_inventory();
+        } else if (boolopt[i].addr == &iflags.use_menu_color
+                   || boolopt[i].addr == &iflags.wc2_guicolor) {
+            update_inventory();
 #endif /* TEXTCOLOR */
-            }
-            return retval;
         }
-    }
-
-    /* Is it a symbol? */
-    if (strstr(opts, "S_") == opts && parsesymbols(opts, PRIMARY)) {
-        switch_symbols(TRUE);
-        check_gold_symbol();
         return retval;
     }
+}
 
-    /* out of valid options */
-    config_error_add("Unknown option '%s'", opts);
-    return FALSE;
+/* Is it a symbol? */
+if (strstr(opts, "S_") == opts && parsesymbols(opts, PRIMARY)) {
+    switch_symbols(TRUE);
+    check_gold_symbol();
+    return retval;
+}
+
+/* out of valid options */
+config_error_add("Unknown option '%s'", opts);
+return FALSE;
 }
 
 /* parse key:command */
@@ -4186,135 +4305,135 @@
 parsebindings(bindings)
 char* bindings;
 {
-    char *bind;
-    char key;
-    int i;
-    boolean ret = FALSE;
+char *bind;
+char key;
+int i;
+boolean ret = FALSE;
 
-    /* break off first binding from the rest; parse the rest */
-    if ((bind = index(bindings, ',')) != 0) {
-        *bind++ = 0;
-        ret |= parsebindings(bind);
-    }
-
-    /* parse a single binding: first split around : */
-    if (! (bind = index(bindings, ':')))
-        return FALSE; /* it's not a binding */
+/* break off first binding from the rest; parse the rest */
+if ((bind = index(bindings, ',')) != 0) {
     *bind++ = 0;
+    ret |= parsebindings(bind);
+}
 
-    /* read the key to be bound */
-    key = txt2key(bindings);
-    if (!key) {
-        config_error_add("Unknown key binding key '%s'", bindings);
-        return FALSE;
-    }
+/* parse a single binding: first split around : */
+if (! (bind = index(bindings, ':')))
+    return FALSE; /* it's not a binding */
+*bind++ = 0;
+
+/* read the key to be bound */
+key = txt2key(bindings);
+if (!key) {
+    config_error_add("Unknown key binding key '%s'", bindings);
+    return FALSE;
+}
 
-    bind = trimspaces(bind);
+bind = trimspaces(bind);
 
-    /* is it a special key? */
-    if (bind_specialkey(key, bind))
-        return TRUE;
+/* is it a special key? */
+if (bind_specialkey(key, bind))
+    return TRUE;
 
-    /* is it a menu command? */
-    for (i = 0; i < SIZE(default_menu_cmd_info); i++) {
-        if (!strcmp(default_menu_cmd_info[i].name, bind)) {
-            if (illegal_menu_cmd_key(key)) {
-                config_error_add("Bad menu key %s:%s", visctrl(key), bind);
-                return FALSE;
-            } else
-                add_menu_cmd_alias(key, default_menu_cmd_info[i].cmd);
-            return TRUE;
-        }
+/* is it a menu command? */
+for (i = 0; i < SIZE(default_menu_cmd_info); i++) {
+    if (!strcmp(default_menu_cmd_info[i].name, bind)) {
+        if (illegal_menu_cmd_key(key)) {
+            config_error_add("Bad menu key %s:%s", visctrl(key), bind);
+            return FALSE;
+        } else
+            add_menu_cmd_alias(key, default_menu_cmd_info[i].cmd);
+        return TRUE;
     }
+}
 
-    /* extended command? */
-    if (!bind_key(key, bind)) {
-        config_error_add("Unknown key binding command '%s'", bind);
-        return FALSE;
-    }
-    return TRUE;
+/* extended command? */
+if (!bind_key(key, bind)) {
+    config_error_add("Unknown key binding command '%s'", bind);
+    return FALSE;
+}
+return TRUE;
 }
 
 static NEARDATA const char *menutype[] = { "traditional", "combination",
-                                           "full", "partial" };
+                                       "full", "partial" };
 
 static NEARDATA const char *burdentype[] = { "unencumbered", "burdened",
-                                             "stressed",     "strained",
-                                             "overtaxed",    "overloaded" };
+                                         "stressed",     "strained",
+                                         "overtaxed",    "overloaded" };
 
 static NEARDATA const char *runmodes[] = { "teleport", "run", "walk",
-                                           "crawl" };
+                                       "crawl" };
 
 static NEARDATA const char *sortltype[] = { "none", "loot", "full" };
 
 /*
- * Convert the given string of object classes to a string of default object
- * symbols.
- */
+* Convert the given string of object classes to a string of default object
+* symbols.
+*/
 void
 oc_to_str(src, dest)
 char *src, *dest;
 {
-    int i;
+int i;
 
-    while ((i = (int) *src++) != 0) {
-        if (i < 0 || i >= MAXOCLASSES)
-            impossible("oc_to_str:  illegal object class %d", i);
-        else
-            *dest++ = def_oc_syms[i].sym;
-    }
-    *dest = '\0';
+while ((i = (int) *src++) != 0) {
+    if (i < 0 || i >= MAXOCLASSES)
+        impossible("oc_to_str:  illegal object class %d", i);
+    else
+        *dest++ = def_oc_syms[i].sym;
+}
+*dest = '\0';
 }
 
 /*
- * Add the given mapping to the menu command map list.  Always keep the
- * maps valid C strings.
- */
+* Add the given mapping to the menu command map list.  Always keep the
+* maps valid C strings.
+*/
 void
 add_menu_cmd_alias(from_ch, to_ch)
 char from_ch, to_ch;
 {
-    if (n_menu_mapped >= MAX_MENU_MAPPED_CMDS) {
-        pline("out of menu map space.");
-    } else {
-        mapped_menu_cmds[n_menu_mapped] = from_ch;
-        mapped_menu_op[n_menu_mapped] = to_ch;
-        n_menu_mapped++;
-        mapped_menu_cmds[n_menu_mapped] = '\0';
-        mapped_menu_op[n_menu_mapped] = '\0';
-    }
+if (n_menu_mapped >= MAX_MENU_MAPPED_CMDS) {
+    pline("out of menu map space.");
+} else {
+    mapped_menu_cmds[n_menu_mapped] = from_ch;
+    mapped_menu_op[n_menu_mapped] = to_ch;
+    n_menu_mapped++;
+    mapped_menu_cmds[n_menu_mapped] = '\0';
+    mapped_menu_op[n_menu_mapped] = '\0';
+}
 }
 
 char
 get_menu_cmd_key(ch)
 char ch;
 {
-    char *found = index(mapped_menu_op, ch);
+char *found = index(mapped_menu_op, ch);
 
-    if (found) {
-        int idx = (int) (found - mapped_menu_op);
+if (found) {
+    int idx = (int) (found - mapped_menu_op);
 
-        ch = mapped_menu_cmds[idx];
-    }
-    return ch;
+    ch = mapped_menu_cmds[idx];
+}
+return ch;
 }
 
 /*
- * Map the given character to its corresponding menu command.  If it
- * doesn't match anything, just return the original.
- */
+* Map the given character to its corresponding menu command.  If it
+* doesn't match anything, just return the original.
+*/
 char
 map_menu_cmd(ch)
 char ch;
 {
-    char *found = index(mapped_menu_cmds, ch);
+char *found = index(mapped_menu_cmds, ch);
 
-    if (found) {
-        int idx = (int) (found - mapped_menu_cmds);
+if (found) {
+    int idx = (int) (found - mapped_menu_cmds);
 
-        ch = mapped_menu_op[idx];
-    }
-    return ch;
+    ch = mapped_menu_op[idx];
+}
+return ch;
 }
 
 void
@@ -4322,70 +4441,70 @@
 winid win;
 boolean dolist;
 {
-    char buf[BUFSZ];
+char buf[BUFSZ];
 
-    putstr(win, 0, "Menu control keys:");
-    if (dolist) {
-        int i;
+putstr(win, 0, "Menu control keys:");
+if (dolist) {
+    int i;
 
-        for (i = 0; i < SIZE(default_menu_cmd_info); i++) {
-            Sprintf(buf, "%-8s %s",
-                    visctrl(get_menu_cmd_key(default_menu_cmd_info[i].cmd)),
-                    default_menu_cmd_info[i].desc);
-            putstr(win, 0, buf);
-        }
-    } else {
-        const char
-            fmt3[] = " %-12s       %-2s        %-2s  %s",
-            fmt2[] = " %-12s       %-2s        %-2s",
-            fmt1[] = " %10s  %-2s  %s",
-            fmt0[] = " %14s  %s";
-
-        putstr(win, 0, "");
-        putstr(win, 0, "Selection:       On page   Full menu");
-        Sprintf(buf, fmt2, "Select all",
-                visctrl(get_menu_cmd_key(MENU_SELECT_PAGE)),
-                visctrl(get_menu_cmd_key(MENU_SELECT_ALL)));
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt2, "Deselect all",
-                visctrl(get_menu_cmd_key(MENU_UNSELECT_PAGE)),
-                visctrl(get_menu_cmd_key(MENU_UNSELECT_ALL)));
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt2, "Invert all",
-                visctrl(get_menu_cmd_key(MENU_INVERT_PAGE)),
-                visctrl(get_menu_cmd_key(MENU_INVERT_ALL)));
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt3, "Text match", "",
-                visctrl(get_menu_cmd_key(MENU_SEARCH)),
-                "Search and toggle matching entries");
-        putstr(win, 0, buf);
-        putstr(win, 0, "");
-        putstr(win, 0, "Navigation:");
-        Sprintf(buf, fmt1, "Go to     ",
-                visctrl(get_menu_cmd_key(MENU_NEXT_PAGE)),
-                "Next page");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt1, "",
-                visctrl(get_menu_cmd_key(MENU_PREVIOUS_PAGE)),
-                "Previous page");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt1, "",
-                visctrl(get_menu_cmd_key(MENU_FIRST_PAGE)),
-                "First page");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt1, "",
-                visctrl(get_menu_cmd_key(MENU_LAST_PAGE)),
-                "Last page");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt0, "SPACE", "Next page, if any, otherwise RETURN");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt0, "RETURN/ENTER",
-                "Finish menu with any selection(s) made");
-        putstr(win, 0, buf);
-        Sprintf(buf, fmt0, "ESCAPE",
-                "Cancel menu without selecting anything");
+    for (i = 0; i < SIZE(default_menu_cmd_info); i++) {
+        Sprintf(buf, "%-8s %s",
+                visctrl(get_menu_cmd_key(default_menu_cmd_info[i].cmd)),
+                default_menu_cmd_info[i].desc);
         putstr(win, 0, buf);
     }
+} else {
+    const char
+        fmt3[] = " %-12s       %-2s        %-2s  %s",
+        fmt2[] = " %-12s       %-2s        %-2s",
+        fmt1[] = " %10s  %-2s  %s",
+        fmt0[] = " %14s  %s";
+
+    putstr(win, 0, "");
+    putstr(win, 0, "Selection:       On page   Full menu");
+    Sprintf(buf, fmt2, "Select all",
+            visctrl(get_menu_cmd_key(MENU_SELECT_PAGE)),
+            visctrl(get_menu_cmd_key(MENU_SELECT_ALL)));
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt2, "Deselect all",
+            visctrl(get_menu_cmd_key(MENU_UNSELECT_PAGE)),
+            visctrl(get_menu_cmd_key(MENU_UNSELECT_ALL)));
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt2, "Invert all",
+            visctrl(get_menu_cmd_key(MENU_INVERT_PAGE)),
+            visctrl(get_menu_cmd_key(MENU_INVERT_ALL)));
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt3, "Text match", "",
+            visctrl(get_menu_cmd_key(MENU_SEARCH)),
+            "Search and toggle matching entries");
+    putstr(win, 0, buf);
+    putstr(win, 0, "");
+    putstr(win, 0, "Navigation:");
+    Sprintf(buf, fmt1, "Go to     ",
+            visctrl(get_menu_cmd_key(MENU_NEXT_PAGE)),
+            "Next page");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt1, "",
+            visctrl(get_menu_cmd_key(MENU_PREVIOUS_PAGE)),
+            "Previous page");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt1, "",
+            visctrl(get_menu_cmd_key(MENU_FIRST_PAGE)),
+            "First page");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt1, "",
+            visctrl(get_menu_cmd_key(MENU_LAST_PAGE)),
+            "Last page");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt0, "SPACE", "Next page, if any, otherwise RETURN");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt0, "RETURN/ENTER",
+            "Finish menu with any selection(s) made");
+    putstr(win, 0, buf);
+    Sprintf(buf, fmt0, "ESCAPE",
+            "Cancel menu without selecting anything");
+    putstr(win, 0, buf);
+}
 }
 
 #if defined(MICRO) || defined(MAC) || defined(WIN32)
@@ -4404,39 +4523,39 @@
 winid win;          /* window to add to */
 const char *option; /* option name */
 int indexoffset;    /* value to add to index in compopt[], or zero
-                       if option cannot be changed */
+                   if option cannot be changed */
 {
-    const char *value = "unknown"; /* current value */
-    char buf[BUFSZ], buf2[BUFSZ];
-    anything any;
-    int i;
+const char *value = "unknown"; /* current value */
+char buf[BUFSZ], buf2[BUFSZ];
+anything any;
+int i;
 
-    any = zeroany;
-    if (indexoffset == 0) {
-        any.a_int = 0;
+any = zeroany;
+if (indexoffset == 0) {
+    any.a_int = 0;
+    value = get_compopt_value(option, buf2);
+} else {
+    for (i = 0; compopt[i].name; i++)
+        if (strcmp(option, compopt[i].name) == 0)
+            break;
+
+    if (compopt[i].name) {
+        any.a_int = i + 1 + indexoffset;
         value = get_compopt_value(option, buf2);
     } else {
-        for (i = 0; compopt[i].name; i++)
-            if (strcmp(option, compopt[i].name) == 0)
-                break;
-
-        if (compopt[i].name) {
-            any.a_int = i + 1 + indexoffset;
-            value = get_compopt_value(option, buf2);
-        } else {
-            /* We are trying to add an option not found in compopt[].
-               This is almost certainly bad, but we'll let it through anyway
-               (with a zero value, so it can't be selected). */
-            any.a_int = 0;
-        }
+        /* We are trying to add an option not found in compopt[].
+           This is almost certainly bad, but we'll let it through anyway
+           (with a zero value, so it can't be selected). */
+        any.a_int = 0;
     }
-    /* "    " replaces "a - " -- assumes menus follow that style */
-    if (!iflags.menu_tab_sep)
-        Sprintf(buf, fmtstr_doset, any.a_int ? "" : "    ", option,
-                value);
-    else
-        Sprintf(buf, fmtstr_doset_tab, option, value);
-    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
+}
+/* "    " replaces "a - " -- assumes menus follow that style */
+if (!iflags.menu_tab_sep)
+    Sprintf(buf, fmtstr_doset, any.a_int ? "" : "    ", option,
+            value);
+else
+    Sprintf(buf, fmtstr_doset_tab, option, value);
+add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
 }
 
 STATIC_OVL void
@@ -4447,268 +4566,268 @@
 char *bufx;
 int nset;
 {
-    char buf[BUFSZ], buf2[BUFSZ];
-    anything any = zeroany;
+char buf[BUFSZ], buf2[BUFSZ];
+anything any = zeroany;
 
-    any.a_int = id;
-    if (!bufx)
-        Sprintf(buf2, n_currently_set, nset);
-    else
-        Sprintf(buf2, "%s", bufx);
-    if (!iflags.menu_tab_sep)
-        Sprintf(buf, fmtstr_doset, any.a_int ? "" : "    ",
-                name, buf2);
-    else
-        Sprintf(buf, fmtstr_doset_tab, name, buf2);
-    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
+any.a_int = id;
+if (!bufx)
+    Sprintf(buf2, n_currently_set, nset);
+else
+    Sprintf(buf2, "%s", bufx);
+if (!iflags.menu_tab_sep)
+    Sprintf(buf, fmtstr_doset, any.a_int ? "" : "    ",
+            name, buf2);
+else
+    Sprintf(buf, fmtstr_doset_tab, name, buf2);
+add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
 }
 
 int
 count_apes(VOID_ARGS)
 {
-    int numapes = 0;
-    struct autopickup_exception *ape = apelist;
+int numapes = 0;
+struct autopickup_exception *ape = apelist;
 
-    while (ape) {
-      numapes++;
-      ape = ape->next;
-    }
+while (ape) {
+  numapes++;
+  ape = ape->next;
+}
 
-    return numapes;
+return numapes;
 }
 
 enum opt_other_enums {
-    OPT_OTHER_MSGTYPE = -4,
-    OPT_OTHER_MENUCOLOR = -3,
-    OPT_OTHER_STATHILITE = -2,
-    OPT_OTHER_APEXC = -1
-    /* these must be < 0 */
+OPT_OTHER_MSGTYPE = -4,
+OPT_OTHER_MENUCOLOR = -3,
+OPT_OTHER_STATHILITE = -2,
+OPT_OTHER_APEXC = -1
+/* these must be < 0 */
 };
 
 static struct other_opts {
-    const char *name;
-    int optflags;
-    enum opt_other_enums code;
-    int NDECL((*othr_count_func));
+const char *name;
+int optflags;
+enum opt_other_enums code;
+int NDECL((*othr_count_func));
 } othropt[] = {
-    { "autopickup exceptions", SET_IN_GAME, OPT_OTHER_APEXC, count_apes },
-    { "menu colors", SET_IN_GAME, OPT_OTHER_MENUCOLOR, count_menucolors },
-    { "message types", SET_IN_GAME, OPT_OTHER_MSGTYPE, msgtype_count },
+{ "autopickup exceptions", SET_IN_GAME, OPT_OTHER_APEXC, count_apes },
+{ "menu colors", SET_IN_GAME, OPT_OTHER_MENUCOLOR, count_menucolors },
+{ "message types", SET_IN_GAME, OPT_OTHER_MSGTYPE, msgtype_count },
 #ifdef STATUS_HILITES
-    { "status hilite rules", SET_IN_GAME, OPT_OTHER_STATHILITE,
-      count_status_hilites },
+{ "status hilite rules", SET_IN_GAME, OPT_OTHER_STATHILITE,
+  count_status_hilites },
 #endif
-    { (char *) 0, 0, (enum opt_other_enums) 0 },
+{ (char *) 0, 0, (enum opt_other_enums) 0 },
 };
 
 /* the 'O' command */
 int
 doset() /* changing options via menu by Per Liboriussen */
 {
-    static boolean made_fmtstr = FALSE;
-    char buf[BUFSZ];
-    const char *name;
-    int i = 0, pass, boolcount, pick_cnt, pick_idx, opt_indx;
-    boolean *bool_p;
-    winid tmpwin;
-    anything any;
-    menu_item *pick_list;
-    int indexoffset, startpass, endpass, optflags;
-    boolean setinitial = FALSE, fromfile = FALSE;
-    unsigned longest_name_len;
+static boolean made_fmtstr = FALSE;
+char buf[BUFSZ];
+const char *name;
+int i = 0, pass, boolcount, pick_cnt, pick_idx, opt_indx;
+boolean *bool_p;
+winid tmpwin;
+anything any;
+menu_item *pick_list;
+int indexoffset, startpass, endpass, optflags;
+boolean setinitial = FALSE, fromfile = FALSE;
+unsigned longest_name_len;
 
-    tmpwin = create_nhwindow(NHW_MENU);
-    start_menu(tmpwin);
+tmpwin = create_nhwindow(NHW_MENU);
+start_menu(tmpwin);
 
 #ifdef notyet /* SYSCF */
-    /* XXX I think this is still fragile.  Fixing initial/from_file and/or
-       changing the SET_* etc to bitmaps will let me make this better. */
-    if (wizard)
-        startpass = SET_IN_SYS;
-    else
-#endif
-        startpass = DISP_IN_GAME;
-    endpass = (wizard) ? SET_IN_WIZGAME : SET_IN_GAME;
-
-    if (!made_fmtstr && !iflags.menu_tab_sep) {
-        /* spin through the options to find the longest name
-           and adjust the format string accordingly */
-        longest_name_len = 0;
-        for (pass = 0; pass <= 2; pass++)
-            for (i = 0; (name = ((pass == 0) ? boolopt[i].name
-                                 : (pass == 1) ? compopt[i].name
-                                   : othropt[i].name)) != 0; i++) {
-                if (pass == 0 && !boolopt[i].addr)
-                    continue;
-                optflags = (pass == 0) ? boolopt[i].optflags
-                           : (pass == 1) ? compopt[i].optflags
-                             : othropt[i].optflags;
-                if (optflags < startpass || optflags > endpass)
-                    continue;
-                if ((is_wc_option(name) && !wc_supported(name))
-                    || (is_wc2_option(name) && !wc2_supported(name)))
-                    continue;
-
-                if (strlen(name) > longest_name_len)
-                    longest_name_len = strlen(name);
-            }
-        Sprintf(fmtstr_doset, "%%s%%-%us [%%s]", longest_name_len);
-        made_fmtstr = TRUE;
-    }
-
-    any = zeroany;
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-             "Booleans (selecting will toggle value):", MENU_UNSELECTED);
-    any.a_int = 0;
-    /* first list any other non-modifiable booleans, then modifiable ones */
-    for (pass = 0; pass <= 1; pass++)
-        for (i = 0; (name = boolopt[i].name) != 0; i++)
-            if ((bool_p = boolopt[i].addr) != 0
-                && ((boolopt[i].optflags <= DISP_IN_GAME && pass == 0)
-                    || (boolopt[i].optflags >= SET_IN_GAME && pass == 1))) {
-                if (bool_p == &flags.female)
-                    continue; /* obsolete */
-                if (boolopt[i].optflags == SET_IN_WIZGAME && !wizard)
-                    continue;
-                if ((is_wc_option(name) && !wc_supported(name))
-                    || (is_wc2_option(name) && !wc2_supported(name)))
-                    continue;
+/* XXX I think this is still fragile.  Fixing initial/from_file and/or
+   changing the SET_* etc to bitmaps will let me make this better. */
+if (wizard)
+    startpass = SET_IN_SYS;
+else
+#endif
+    startpass = DISP_IN_GAME;
+endpass = (wizard) ? SET_IN_WIZGAME : SET_IN_GAME;
+
+if (!made_fmtstr && !iflags.menu_tab_sep) {
+    /* spin through the options to find the longest name
+       and adjust the format string accordingly */
+    longest_name_len = 0;
+    for (pass = 0; pass <= 2; pass++)
+        for (i = 0; (name = ((pass == 0) ? boolopt[i].name
+                             : (pass == 1) ? compopt[i].name
+                               : othropt[i].name)) != 0; i++) {
+            if (pass == 0 && !boolopt[i].addr)
+                continue;
+            optflags = (pass == 0) ? boolopt[i].optflags
+                       : (pass == 1) ? compopt[i].optflags
+                         : othropt[i].optflags;
+            if (optflags < startpass || optflags > endpass)
+                continue;
+            if ((is_wc_option(name) && !wc_supported(name))
+                || (is_wc2_option(name) && !wc2_supported(name)))
+                continue;
 
-                any.a_int = (pass == 0) ? 0 : i + 1;
-                if (!iflags.menu_tab_sep)
-                    Sprintf(buf, fmtstr_doset, (pass == 0) ? "    " : "",
-                            name, *bool_p ? "true" : "false");
-                else
-                    Sprintf(buf, fmtstr_doset_tab,
-                            name, *bool_p ? "true" : "false");
-                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf,
-                         MENU_UNSELECTED);
-            }
+            if (strlen(name) > longest_name_len)
+                longest_name_len = strlen(name);
+        }
+    Sprintf(fmtstr_doset, "%%s%%-%us [%%s]", longest_name_len);
+    made_fmtstr = TRUE;
+}
 
-    boolcount = i;
-    indexoffset = boolcount;
-    any = zeroany;
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-             "Compounds (selecting will prompt for new value):",
-             MENU_UNSELECTED);
+any = zeroany;
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+         "Booleans (selecting will toggle value):", MENU_UNSELECTED);
+any.a_int = 0;
+/* first list any other non-modifiable booleans, then modifiable ones */
+for (pass = 0; pass <= 1; pass++)
+    for (i = 0; (name = boolopt[i].name) != 0; i++)
+        if ((bool_p = boolopt[i].addr) != 0
+            && ((boolopt[i].optflags <= DISP_IN_GAME && pass == 0)
+                || (boolopt[i].optflags >= SET_IN_GAME && pass == 1))) {
+            if (bool_p == &flags.female)
+                continue; /* obsolete */
+            if (boolopt[i].optflags == SET_IN_WIZGAME && !wizard)
+                continue;
+            if ((is_wc_option(name) && !wc_supported(name))
+                || (is_wc2_option(name) && !wc2_supported(name)))
+                continue;
 
-    /* deliberately put playmode, name, role+race+gender+align first */
-    doset_add_menu(tmpwin, "playmode", 0);
-    doset_add_menu(tmpwin, "name", 0);
-    doset_add_menu(tmpwin, "role", 0);
-    doset_add_menu(tmpwin, "race", 0);
-    doset_add_menu(tmpwin, "gender", 0);
-    doset_add_menu(tmpwin, "align", 0);
-
-    for (pass = startpass; pass <= endpass; pass++)
-        for (i = 0; (name = compopt[i].name) != 0; i++)
-            if (compopt[i].optflags == pass) {
-                if (!strcmp(name, "playmode")  || !strcmp(name, "name")
-                    || !strcmp(name, "role")   || !strcmp(name, "race")
-                    || !strcmp(name, "gender") || !strcmp(name, "align"))
-                    continue;
-                if ((is_wc_option(name) && !wc_supported(name))
-                    || (is_wc2_option(name) && !wc2_supported(name)))
-                    continue;
+            any.a_int = (pass == 0) ? 0 : i + 1;
+            if (!iflags.menu_tab_sep)
+                Sprintf(buf, fmtstr_doset, (pass == 0) ? "    " : "",
+                        name, *bool_p ? "true" : "false");
+            else
+                Sprintf(buf, fmtstr_doset_tab,
+                        name, *bool_p ? "true" : "false");
+            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf,
+                     MENU_UNSELECTED);
+        }
 
-                doset_add_menu(tmpwin, name,
-                               (pass == DISP_IN_GAME) ? 0 : indexoffset);
-            }
+boolcount = i;
+indexoffset = boolcount;
+any = zeroany;
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+         "Compounds (selecting will prompt for new value):",
+         MENU_UNSELECTED);
+
+/* deliberately put playmode, name, role+race+gender+align first */
+doset_add_menu(tmpwin, "playmode", 0);
+doset_add_menu(tmpwin, "name", 0);
+doset_add_menu(tmpwin, "role", 0);
+doset_add_menu(tmpwin, "race", 0);
+doset_add_menu(tmpwin, "gender", 0);
+doset_add_menu(tmpwin, "align", 0);
+
+for (pass = startpass; pass <= endpass; pass++)
+    for (i = 0; (name = compopt[i].name) != 0; i++)
+        if (compopt[i].optflags == pass) {
+            if (!strcmp(name, "playmode")  || !strcmp(name, "name")
+                || !strcmp(name, "role")   || !strcmp(name, "race")
+                || !strcmp(name, "gender") || !strcmp(name, "align"))
+                continue;
+            if ((is_wc_option(name) && !wc_supported(name))
+                || (is_wc2_option(name) && !wc2_supported(name)))
+                continue;
 
-    any = zeroany;
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-             "Other settings:", MENU_UNSELECTED);
+            doset_add_menu(tmpwin, name,
+                           (pass == DISP_IN_GAME) ? 0 : indexoffset);
+        }
 
-    for (i = 0; (name = othropt[i].name) != 0; i++) {
-        if ((is_wc_option(name) && !wc_supported(name))
-            || (is_wc2_option(name) && !wc2_supported(name)))
-            continue;
-        opts_add_others(tmpwin, name, othropt[i].code,
-                        (char *) 0, othropt[i].othr_count_func());
-    }
+any = zeroany;
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+         "Other settings:", MENU_UNSELECTED);
+
+for (i = 0; (name = othropt[i].name) != 0; i++) {
+    if ((is_wc_option(name) && !wc_supported(name))
+        || (is_wc2_option(name) && !wc2_supported(name)))
+        continue;
+    opts_add_others(tmpwin, name, othropt[i].code,
+                    (char *) 0, othropt[i].othr_count_func());
+}
 
 #ifdef PREFIXES_IN_USE
-    any = zeroany;
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-             "Variable playground locations:", MENU_UNSELECTED);
-    for (i = 0; i < PREFIX_COUNT; i++)
-        doset_add_menu(tmpwin, fqn_prefix_names[i], 0);
-#endif
-    end_menu(tmpwin, "Set what options?");
-    need_redraw = FALSE;
-    if ((pick_cnt = select_menu(tmpwin, PICK_ANY, &pick_list)) > 0) {
-        /*
-         * Walk down the selection list and either invert the booleans
-         * or prompt for new values. In most cases, call parseoptions()
-         * to take care of options that require special attention, like
-         * redraws.
-         */
-        for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
-            opt_indx = pick_list[pick_idx].item.a_int - 1;
-            if (opt_indx < -1)
-                opt_indx++; /* -1 offset for select_menu() */
-            if (opt_indx == OPT_OTHER_APEXC) {
-                (void) special_handling("autopickup_exception", setinitial,
-                                        fromfile);
+any = zeroany;
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+         "Variable playground locations:", MENU_UNSELECTED);
+for (i = 0; i < PREFIX_COUNT; i++)
+    doset_add_menu(tmpwin, fqn_prefix_names[i], 0);
+#endif
+end_menu(tmpwin, "Set what options?");
+need_redraw = FALSE;
+if ((pick_cnt = select_menu(tmpwin, PICK_ANY, &pick_list)) > 0) {
+    /*
+     * Walk down the selection list and either invert the booleans
+     * or prompt for new values. In most cases, call parseoptions()
+     * to take care of options that require special attention, like
+     * redraws.
+     */
+    for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
+        opt_indx = pick_list[pick_idx].item.a_int - 1;
+        if (opt_indx < -1)
+            opt_indx++; /* -1 offset for select_menu() */
+        if (opt_indx == OPT_OTHER_APEXC) {
+            (void) special_handling("autopickup_exception", setinitial,
+                                    fromfile);
 #ifdef STATUS_HILITES
-            } else if (opt_indx == OPT_OTHER_STATHILITE) {
-                if (!status_hilite_menu()) {
-                    pline("Bad status hilite(s) specified.");
-                } else {
-                    if (wc2_supported("hilite_status"))
-                        preference_update("hilite_status");
-                }
-#endif
-            } else if (opt_indx == OPT_OTHER_MENUCOLOR) {
-                    (void) special_handling("menu_colors", setinitial,
-                                            fromfile);
-            } else if (opt_indx == OPT_OTHER_MSGTYPE) {
-                    (void) special_handling("msgtype", setinitial, fromfile);
-            } else if (opt_indx < boolcount) {
-                /* boolean option */
-                Sprintf(buf, "%s%s", *boolopt[opt_indx].addr ? "!" : "",
-                        boolopt[opt_indx].name);
-                (void) parseoptions(buf, setinitial, fromfile);
-                if (wc_supported(boolopt[opt_indx].name)
-                    || wc2_supported(boolopt[opt_indx].name))
-                    preference_update(boolopt[opt_indx].name);
+        } else if (opt_indx == OPT_OTHER_STATHILITE) {
+            if (!status_hilite_menu()) {
+                pline("Bad status hilite(s) specified.");
             } else {
-                /* compound option */
-                opt_indx -= boolcount;
+                if (wc2_supported("hilite_status"))
+                    preference_update("hilite_status");
+            }
+#endif
+        } else if (opt_indx == OPT_OTHER_MENUCOLOR) {
+                (void) special_handling("menu_colors", setinitial,
+                                        fromfile);
+        } else if (opt_indx == OPT_OTHER_MSGTYPE) {
+                (void) special_handling("msgtype", setinitial, fromfile);
+        } else if (opt_indx < boolcount) {
+            /* boolean option */
+            Sprintf(buf, "%s%s", *boolopt[opt_indx].addr ? "!" : "",
+                    boolopt[opt_indx].name);
+            (void) parseoptions(buf, setinitial, fromfile);
+            if (wc_supported(boolopt[opt_indx].name)
+                || wc2_supported(boolopt[opt_indx].name))
+                preference_update(boolopt[opt_indx].name);
+        } else {
+            /* compound option */
+            opt_indx -= boolcount;
 
-                if (!special_handling(compopt[opt_indx].name, setinitial,
-                                      fromfile)) {
-                    char abuf[BUFSZ];
-
-                    Sprintf(buf, "Set %s to what?", compopt[opt_indx].name);
-                    abuf[0] = '\0';
-                    getlin(buf, abuf);
-                    if (abuf[0] == '\033')
-                        continue;
-                    Sprintf(buf, "%s:", compopt[opt_indx].name);
-                    (void) strncat(eos(buf), abuf,
-                                   (sizeof buf - 1 - strlen(buf)));
-                    /* pass the buck */
-                    (void) parseoptions(buf, setinitial, fromfile);
-                }
-                if (wc_supported(compopt[opt_indx].name)
-                    || wc2_supported(compopt[opt_indx].name))
-                    preference_update(compopt[opt_indx].name);
+            if (!special_handling(compopt[opt_indx].name, setinitial,
+                                  fromfile)) {
+                char abuf[BUFSZ];
+
+                Sprintf(buf, "Set %s to what?", compopt[opt_indx].name);
+                abuf[0] = '\0';
+                getlin(buf, abuf);
+                if (abuf[0] == '\033')
+                    continue;
+                Sprintf(buf, "%s:", compopt[opt_indx].name);
+                (void) strncat(eos(buf), abuf,
+                               (sizeof buf - 1 - strlen(buf)));
+                /* pass the buck */
+                (void) parseoptions(buf, setinitial, fromfile);
             }
+            if (wc_supported(compopt[opt_indx].name)
+                || wc2_supported(compopt[opt_indx].name))
+                preference_update(compopt[opt_indx].name);
         }
-        free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
     }
+    free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
+}
 
-    destroy_nhwindow(tmpwin);
-    if (need_redraw) {
-        check_gold_symbol();
-        reglyph_darkroom();
-        (void) doredraw();
-    }
-    return 0;
+destroy_nhwindow(tmpwin);
+if (need_redraw) {
+    check_gold_symbol();
+    reglyph_darkroom();
+    (void) doredraw();
+}
+return 0;
 }
 
 /* common to msg-types, menu-colors, autopickup-exceptions */
@@ -4717,1034 +4836,1034 @@
 const char *optname;
 int numtotal;
 {
-    winid tmpwin;
-    anything any;
-    int i, pick_cnt, opt_idx;
-    menu_item *pick_list = (menu_item *) 0;
-    static const struct action {
-        char letr;
-        const char *desc;
-    } action_titles[] = {
-        { 'a', "add new %s" },         /* [0] */
-        { 'l', "list %s" },            /* [1] */
-        { 'r', "remove existing %s" }, /* [2] */
-        { 'x', "exit this menu" },     /* [3] */
-    };
-
-    opt_idx = 0;
-    tmpwin = create_nhwindow(NHW_MENU);
-    start_menu(tmpwin);
-    any = zeroany;
-    for (i = 0; i < SIZE(action_titles); i++) {
-        char tmpbuf[BUFSZ];
+winid tmpwin;
+anything any;
+int i, pick_cnt, opt_idx;
+menu_item *pick_list = (menu_item *) 0;
+static const struct action {
+    char letr;
+    const char *desc;
+} action_titles[] = {
+    { 'a', "add new %s" },         /* [0] */
+    { 'l', "list %s" },            /* [1] */
+    { 'r', "remove existing %s" }, /* [2] */
+    { 'x', "exit this menu" },     /* [3] */
+};
 
-        any.a_int++;
-        /* omit list and remove if there aren't any yet */
-        if (!numtotal && (i == 1 || i == 2))
-            continue;
-        Sprintf(tmpbuf, action_titles[i].desc,
-                (i == 1) ? makeplural(optname) : optname);
-        add_menu(tmpwin, NO_GLYPH, &any, action_titles[i].letr, 0, ATR_NONE,
-                 tmpbuf, (i == 3) ? MENU_SELECTED : MENU_UNSELECTED);
-    }
-    end_menu(tmpwin, "Do what?");
-    if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &pick_list)) > 0) {
-        opt_idx = pick_list[0].item.a_int - 1;
-        if (pick_cnt > 1 && opt_idx == 3)
-            opt_idx = pick_list[1].item.a_int - 1;
-        free((genericptr_t) pick_list);
-    } else
-        opt_idx = 3; /* none selected, exit menu */
-    destroy_nhwindow(tmpwin);
-    return opt_idx;
+opt_idx = 0;
+tmpwin = create_nhwindow(NHW_MENU);
+start_menu(tmpwin);
+any = zeroany;
+for (i = 0; i < SIZE(action_titles); i++) {
+    char tmpbuf[BUFSZ];
+
+    any.a_int++;
+    /* omit list and remove if there aren't any yet */
+    if (!numtotal && (i == 1 || i == 2))
+        continue;
+    Sprintf(tmpbuf, action_titles[i].desc,
+            (i == 1) ? makeplural(optname) : optname);
+    add_menu(tmpwin, NO_GLYPH, &any, action_titles[i].letr, 0, ATR_NONE,
+             tmpbuf, (i == 3) ? MENU_SELECTED : MENU_UNSELECTED);
+}
+end_menu(tmpwin, "Do what?");
+if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &pick_list)) > 0) {
+    opt_idx = pick_list[0].item.a_int - 1;
+    if (pick_cnt > 1 && opt_idx == 3)
+        opt_idx = pick_list[1].item.a_int - 1;
+    free((genericptr_t) pick_list);
+} else
+    opt_idx = 3; /* none selected, exit menu */
+destroy_nhwindow(tmpwin);
+return opt_idx;
 }
 
 struct symsetentry *symset_list = 0; /* files.c will populate this with
-                                      * list of available sets */
+                                  * list of available sets */
 
 STATIC_OVL boolean
 special_handling(optname, setinitial, setfromfile)
 const char *optname;
 boolean setinitial, setfromfile;
 {
-    winid tmpwin;
-    anything any;
-    int i, n;
-    char buf[BUFSZ];
-
-    /* Special handling of menustyle, pickup_burden, pickup_types,
-     * disclose, runmode, msg_window, menu_headings, sortloot,
-     * and number_pad options.
-     * Also takes care of interactive autopickup_exception_handling changes.
-     */
-    if (!strcmp("menustyle", optname)) {
-        const char *style_name;
-        menu_item *style_pick = (menu_item *) 0;
+winid tmpwin;
+anything any;
+int i, n;
+char buf[BUFSZ];
+
+/* Special handling of menustyle, pickup_burden, pickup_types,
+ * disclose, runmode, msg_window, menu_headings, sortloot,
+ * and number_pad options.
+ * Also takes care of interactive autopickup_exception_handling changes.
+ */
+if (!strcmp("menustyle", optname)) {
+    const char *style_name;
+    menu_item *style_pick = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; i < SIZE(menutype); i++) {
-            style_name = menutype[i];
-            /* note: separate `style_name' variable used
-               to avoid an optimizer bug in VAX C V2.3 */
-            any.a_int = i + 1;
-            add_menu(tmpwin, NO_GLYPH, &any, *style_name, 0, ATR_NONE,
-                     style_name, MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Select menustyle:");
-        if (select_menu(tmpwin, PICK_ONE, &style_pick) > 0) {
-            flags.menu_style = style_pick->item.a_int - 1;
-            free((genericptr_t) style_pick);
-        }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("paranoid_confirmation", optname)) {
-        menu_item *paranoia_picks = (menu_item *) 0;
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < SIZE(menutype); i++) {
+        style_name = menutype[i];
+        /* note: separate `style_name' variable used
+           to avoid an optimizer bug in VAX C V2.3 */
+        any.a_int = i + 1;
+        add_menu(tmpwin, NO_GLYPH, &any, *style_name, 0, ATR_NONE,
+                 style_name, MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Select menustyle:");
+    if (select_menu(tmpwin, PICK_ONE, &style_pick) > 0) {
+        flags.menu_style = style_pick->item.a_int - 1;
+        free((genericptr_t) style_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("paranoid_confirmation", optname)) {
+    menu_item *paranoia_picks = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; paranoia[i].flagmask != 0; ++i) {
-            if (paranoia[i].flagmask == PARANOID_BONES && !wizard)
-                continue;
-            any.a_int = paranoia[i].flagmask;
-            add_menu(tmpwin, NO_GLYPH, &any, *paranoia[i].argname, 0,
-                     ATR_NONE, paranoia[i].explain,
-                     (flags.paranoia_bits & paranoia[i].flagmask)
-                         ? MENU_SELECTED
-                         : MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Actions requiring extra confirmation:");
-        i = select_menu(tmpwin, PICK_ANY, &paranoia_picks);
-        if (i >= 0) {
-            /* player didn't cancel; we reset all the paranoia options
-               here even if there were no items picked, since user
-               could have toggled off preselected ones to end up with 0 */
-            flags.paranoia_bits = 0;
-            if (i > 0) {
-                /* at least 1 item set, either preselected or newly picked */
-                while (--i >= 0)
-                    flags.paranoia_bits |= paranoia_picks[i].item.a_int;
-                free((genericptr_t) paranoia_picks);
-            }
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; paranoia[i].flagmask != 0; ++i) {
+        if (paranoia[i].flagmask == PARANOID_BONES && !wizard)
+            continue;
+        any.a_int = paranoia[i].flagmask;
+        add_menu(tmpwin, NO_GLYPH, &any, *paranoia[i].argname, 0,
+                 ATR_NONE, paranoia[i].explain,
+                 (flags.paranoia_bits & paranoia[i].flagmask)
+                     ? MENU_SELECTED
+                     : MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Actions requiring extra confirmation:");
+    i = select_menu(tmpwin, PICK_ANY, &paranoia_picks);
+    if (i >= 0) {
+        /* player didn't cancel; we reset all the paranoia options
+           here even if there were no items picked, since user
+           could have toggled off preselected ones to end up with 0 */
+        flags.paranoia_bits = 0;
+        if (i > 0) {
+            /* at least 1 item set, either preselected or newly picked */
+            while (--i >= 0)
+                flags.paranoia_bits |= paranoia_picks[i].item.a_int;
+            free((genericptr_t) paranoia_picks);
         }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("pickup_burden", optname)) {
-        const char *burden_name, *burden_letters = "ubsntl";
-        menu_item *burden_pick = (menu_item *) 0;
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("pickup_burden", optname)) {
+    const char *burden_name, *burden_letters = "ubsntl";
+    menu_item *burden_pick = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; i < SIZE(burdentype); i++) {
-            burden_name = burdentype[i];
-            any.a_int = i + 1;
-            add_menu(tmpwin, NO_GLYPH, &any, burden_letters[i], 0, ATR_NONE,
-                     burden_name, MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Select encumbrance level:");
-        if (select_menu(tmpwin, PICK_ONE, &burden_pick) > 0) {
-            flags.pickup_burden = burden_pick->item.a_int - 1;
-            free((genericptr_t) burden_pick);
-        }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("pickup_types", optname)) {
-        /* parseoptions will prompt for the list of types */
-        (void) parseoptions(strcpy(buf, "pickup_types"),
-                            setinitial, setfromfile);
-    } else if (!strcmp("disclose", optname)) {
-        /* order of disclose_names[] must correspond to
-           disclosure_options in decl.c */
-        static const char *disclosure_names[] = {
-            "inventory", "attributes", "vanquished",
-            "genocides", "conduct",    "overview",
-        };
-        int disc_cat[NUM_DISCLOSURE_OPTIONS];
-        int pick_cnt, pick_idx, opt_idx;
-        char c;
-        menu_item *disclosure_pick = (menu_item *) 0;
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < SIZE(burdentype); i++) {
+        burden_name = burdentype[i];
+        any.a_int = i + 1;
+        add_menu(tmpwin, NO_GLYPH, &any, burden_letters[i], 0, ATR_NONE,
+                 burden_name, MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Select encumbrance level:");
+    if (select_menu(tmpwin, PICK_ONE, &burden_pick) > 0) {
+        flags.pickup_burden = burden_pick->item.a_int - 1;
+        free((genericptr_t) burden_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("pickup_types", optname)) {
+    /* parseoptions will prompt for the list of types */
+    (void) parseoptions(strcpy(buf, "pickup_types"),
+                        setinitial, setfromfile);
+} else if (!strcmp("disclose", optname)) {
+    /* order of disclose_names[] must correspond to
+       disclosure_options in decl.c */
+    static const char *disclosure_names[] = {
+        "inventory", "attributes", "vanquished",
+        "genocides", "conduct",    "overview",
+    };
+    int disc_cat[NUM_DISCLOSURE_OPTIONS];
+    int pick_cnt, pick_idx, opt_idx;
+    char c;
+    menu_item *disclosure_pick = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
-            Sprintf(buf, "%-12s[%c%c]", disclosure_names[i],
-                    flags.end_disclose[i], disclosure_options[i]);
-            any.a_int = i + 1;
-            add_menu(tmpwin, NO_GLYPH, &any, disclosure_options[i], 0,
-                     ATR_NONE, buf, MENU_UNSELECTED);
-            disc_cat[i] = 0;
-        }
-        end_menu(tmpwin, "Change which disclosure options categories:");
-        pick_cnt = select_menu(tmpwin, PICK_ANY, &disclosure_pick);
-        if (pick_cnt > 0) {
-            for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
-                opt_idx = disclosure_pick[pick_idx].item.a_int - 1;
-                disc_cat[opt_idx] = 1;
-            }
-            free((genericptr_t) disclosure_pick);
-            disclosure_pick = (menu_item *) 0;
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
+        Sprintf(buf, "%-12s[%c%c]", disclosure_names[i],
+                flags.end_disclose[i], disclosure_options[i]);
+        any.a_int = i + 1;
+        add_menu(tmpwin, NO_GLYPH, &any, disclosure_options[i], 0,
+                 ATR_NONE, buf, MENU_UNSELECTED);
+        disc_cat[i] = 0;
+    }
+    end_menu(tmpwin, "Change which disclosure options categories:");
+    pick_cnt = select_menu(tmpwin, PICK_ANY, &disclosure_pick);
+    if (pick_cnt > 0) {
+        for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
+            opt_idx = disclosure_pick[pick_idx].item.a_int - 1;
+            disc_cat[opt_idx] = 1;
         }
-        destroy_nhwindow(tmpwin);
+        free((genericptr_t) disclosure_pick);
+        disclosure_pick = (menu_item *) 0;
+    }
+    destroy_nhwindow(tmpwin);
 
-        for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
-            if (disc_cat[i]) {
-                c = flags.end_disclose[i];
-                Sprintf(buf, "Disclosure options for %s:",
-                        disclosure_names[i]);
-                tmpwin = create_nhwindow(NHW_MENU);
-                start_menu(tmpwin);
-                any = zeroany;
-                /* 'y','n',and '+' work as alternate selectors; '-' doesn't */
-                any.a_char = DISCLOSE_NO_WITHOUT_PROMPT;
-                add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                         "Never disclose, without prompting",
-                         (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
-                any.a_char = DISCLOSE_YES_WITHOUT_PROMPT;
-                add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                         "Always disclose, without prompting",
-                         (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
-                if (*disclosure_names[i] == 'v') {
-                    any.a_char = DISCLOSE_SPECIAL_WITHOUT_PROMPT; /* '#' */
-                    add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                             "Always disclose, pick sort order from menu",
-                             (c == any.a_char) ? MENU_SELECTED
-                                               : MENU_UNSELECTED);
-                }
-                any.a_char = DISCLOSE_PROMPT_DEFAULT_NO;
+    for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
+        if (disc_cat[i]) {
+            c = flags.end_disclose[i];
+            Sprintf(buf, "Disclosure options for %s:",
+                    disclosure_names[i]);
+            tmpwin = create_nhwindow(NHW_MENU);
+            start_menu(tmpwin);
+            any = zeroany;
+            /* 'y','n',and '+' work as alternate selectors; '-' doesn't */
+            any.a_char = DISCLOSE_NO_WITHOUT_PROMPT;
+            add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
+                     "Never disclose, without prompting",
+                     (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
+            any.a_char = DISCLOSE_YES_WITHOUT_PROMPT;
+            add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
+                     "Always disclose, without prompting",
+                     (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
+            if (*disclosure_names[i] == 'v') {
+                any.a_char = DISCLOSE_SPECIAL_WITHOUT_PROMPT; /* '#' */
                 add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                         "Prompt, with default answer of \"No\"",
-                         (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
-                any.a_char = DISCLOSE_PROMPT_DEFAULT_YES;
+                         "Always disclose, pick sort order from menu",
+                         (c == any.a_char) ? MENU_SELECTED
+                                           : MENU_UNSELECTED);
+            }
+            any.a_char = DISCLOSE_PROMPT_DEFAULT_NO;
+            add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
+                     "Prompt, with default answer of \"No\"",
+                     (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
+            any.a_char = DISCLOSE_PROMPT_DEFAULT_YES;
+            add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
+                     "Prompt, with default answer of \"Yes\"",
+                     (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
+            if (*disclosure_names[i] == 'v') {
+                any.a_char = DISCLOSE_PROMPT_DEFAULT_SPECIAL; /* '?' */
                 add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                         "Prompt, with default answer of \"Yes\"",
-                         (c == any.a_char) ? MENU_SELECTED : MENU_UNSELECTED);
-                if (*disclosure_names[i] == 'v') {
-                    any.a_char = DISCLOSE_PROMPT_DEFAULT_SPECIAL; /* '?' */
-                    add_menu(tmpwin, NO_GLYPH, &any, 0, any.a_char, ATR_NONE,
-                "Prompt, with default answer of \"Ask\" to request sort menu",
-                             (c == any.a_char) ? MENU_SELECTED
-                                               : MENU_UNSELECTED);
-                }
-                end_menu(tmpwin, buf);
-                n = select_menu(tmpwin, PICK_ONE, &disclosure_pick);
-                if (n > 0) {
-                    flags.end_disclose[i] = disclosure_pick[0].item.a_char;
-                    if (n > 1 && flags.end_disclose[i] == c)
-                        flags.end_disclose[i] = disclosure_pick[1].item.a_char;
-                    free((genericptr_t) disclosure_pick);
-                }
-                destroy_nhwindow(tmpwin);
+            "Prompt, with default answer of \"Ask\" to request sort menu",
+                         (c == any.a_char) ? MENU_SELECTED
+                                           : MENU_UNSELECTED);
+            }
+            end_menu(tmpwin, buf);
+            n = select_menu(tmpwin, PICK_ONE, &disclosure_pick);
+            if (n > 0) {
+                flags.end_disclose[i] = disclosure_pick[0].item.a_char;
+                if (n > 1 && flags.end_disclose[i] == c)
+                    flags.end_disclose[i] = disclosure_pick[1].item.a_char;
+                free((genericptr_t) disclosure_pick);
             }
+            destroy_nhwindow(tmpwin);
         }
-    } else if (!strcmp("runmode", optname)) {
-        const char *mode_name;
-        menu_item *mode_pick = (menu_item *) 0;
+    }
+} else if (!strcmp("runmode", optname)) {
+    const char *mode_name;
+    menu_item *mode_pick = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; i < SIZE(runmodes); i++) {
-            mode_name = runmodes[i];
-            any.a_int = i + 1;
-            add_menu(tmpwin, NO_GLYPH, &any, *mode_name, 0, ATR_NONE,
-                     mode_name, MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Select run/travel display mode:");
-        if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
-            flags.runmode = mode_pick->item.a_int - 1;
-            free((genericptr_t) mode_pick);
-        }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("whatis_coord", optname)) {
-        menu_item *window_pick = (menu_item *) 0;
-        int pick_cnt;
-        char gp = iflags.getpos_coords;
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < SIZE(runmodes); i++) {
+        mode_name = runmodes[i];
+        any.a_int = i + 1;
+        add_menu(tmpwin, NO_GLYPH, &any, *mode_name, 0, ATR_NONE,
+                 mode_name, MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Select run/travel display mode:");
+    if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
+        flags.runmode = mode_pick->item.a_int - 1;
+        free((genericptr_t) mode_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("whatis_coord", optname)) {
+    menu_item *window_pick = (menu_item *) 0;
+    int pick_cnt;
+    char gp = iflags.getpos_coords;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        any.a_char = GPCOORDS_COMPASS;
-        add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_COMPASS, 0, ATR_NONE,
-                 "compass ('east' or '3s' or '2n,4w')",
-                 (gp == GPCOORDS_COMPASS) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = GPCOORDS_COMFULL;
-        add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_COMFULL, 0, ATR_NONE,
-                 "full compass ('east' or '3south' or '2north,4west')",
-                 (gp == GPCOORDS_COMFULL) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = GPCOORDS_MAP;
-        add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_MAP, 0, ATR_NONE,
-                 "map <x,y>",
-                 (gp == GPCOORDS_MAP) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = GPCOORDS_SCREEN;
-        add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_SCREEN, 0, ATR_NONE,
-                 "screen [row,column]",
-                 (gp == GPCOORDS_SCREEN) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = GPCOORDS_NONE;
-        add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_NONE, 0, ATR_NONE,
-                 "none (no coordinates displayed)",
-                 (gp == GPCOORDS_NONE) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_long = 0L;
-        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-        Sprintf(buf, "map: upper-left: <%d,%d>, lower-right: <%d,%d>%s",
-                1, 0, COLNO - 1, ROWNO - 1,
-                flags.verbose ? "; column 0 unused, off left edge" : "");
-        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
-        if (strcmp(windowprocs.name, "tty")) /* only show for non-tty */
-            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE,
-       "screen: row is offset to accommodate tty interface's use of top line",
-                     MENU_UNSELECTED);
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    any.a_char = GPCOORDS_COMPASS;
+    add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_COMPASS, 0, ATR_NONE,
+             "compass ('east' or '3s' or '2n,4w')",
+             (gp == GPCOORDS_COMPASS) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = GPCOORDS_COMFULL;
+    add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_COMFULL, 0, ATR_NONE,
+             "full compass ('east' or '3south' or '2north,4west')",
+             (gp == GPCOORDS_COMFULL) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = GPCOORDS_MAP;
+    add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_MAP, 0, ATR_NONE,
+             "map <x,y>",
+             (gp == GPCOORDS_MAP) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = GPCOORDS_SCREEN;
+    add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_SCREEN, 0, ATR_NONE,
+             "screen [row,column]",
+             (gp == GPCOORDS_SCREEN) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = GPCOORDS_NONE;
+    add_menu(tmpwin, NO_GLYPH, &any, GPCOORDS_NONE, 0, ATR_NONE,
+             "none (no coordinates displayed)",
+             (gp == GPCOORDS_NONE) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_long = 0L;
+    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+    Sprintf(buf, "map: upper-left: <%d,%d>, lower-right: <%d,%d>%s",
+            1, 0, COLNO - 1, ROWNO - 1,
+            flags.verbose ? "; column 0 unused, off left edge" : "");
+    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
+    if (strcmp(windowprocs.name, "tty")) /* only show for non-tty */
+        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE,
+   "screen: row is offset to accommodate tty interface's use of top line",
+                 MENU_UNSELECTED);
 #if COLNO == 80
 #define COL80ARG flags.verbose ? "; column 80 is not used" : ""
 #else
 #define COL80ARG ""
 #endif
-        Sprintf(buf, "screen: upper-left: [%02d,%02d], lower-right: [%d,%d]%s",
-                0 + 2, 1, ROWNO - 1 + 2, COLNO - 1, COL80ARG);
+    Sprintf(buf, "screen: upper-left: [%02d,%02d], lower-right: [%d,%d]%s",
+            0 + 2, 1, ROWNO - 1 + 2, COLNO - 1, COL80ARG);
 #undef COL80ARG
-        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
-        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-        end_menu(tmpwin,
-            "Select coordinate display when auto-describing a map position:");
-        if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &window_pick)) > 0) {
-            iflags.getpos_coords = window_pick[0].item.a_char;
-            /* PICK_ONE doesn't unselect preselected entry when
-               selecting another one */
-            if (pick_cnt > 1 && iflags.getpos_coords == gp)
-                iflags.getpos_coords = window_pick[1].item.a_char;
-            free((genericptr_t) window_pick);
-        }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("whatis_filter", optname)) {
+    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
+    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+    end_menu(tmpwin,
+        "Select coordinate display when auto-describing a map position:");
+    if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &window_pick)) > 0) {
+        iflags.getpos_coords = window_pick[0].item.a_char;
+        /* PICK_ONE doesn't unselect preselected entry when
+           selecting another one */
+        if (pick_cnt > 1 && iflags.getpos_coords == gp)
+            iflags.getpos_coords = window_pick[1].item.a_char;
+        free((genericptr_t) window_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("whatis_filter", optname)) {
+    menu_item *window_pick = (menu_item *) 0;
+    int pick_cnt;
+    char gf = iflags.getloc_filter;
+
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    any.a_char = (GFILTER_NONE + 1);
+    add_menu(tmpwin, NO_GLYPH, &any, 'n',
+             0, ATR_NONE, "no filtering",
+             (gf == GFILTER_NONE) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = (GFILTER_VIEW + 1);
+    add_menu(tmpwin, NO_GLYPH, &any, 'v',
+             0, ATR_NONE, "in view only",
+             (gf == GFILTER_VIEW) ? MENU_SELECTED : MENU_UNSELECTED);
+    any.a_char = (GFILTER_AREA + 1);
+    add_menu(tmpwin, NO_GLYPH, &any, 'a',
+             0, ATR_NONE, "in same area",
+             (gf == GFILTER_AREA) ? MENU_SELECTED : MENU_UNSELECTED);
+    end_menu(tmpwin,
+  "Select location filtering when going for next/previous map position:");
+    if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &window_pick)) > 0) {
+        iflags.getloc_filter = (window_pick[0].item.a_char - 1);
+        /* PICK_ONE doesn't unselect preselected entry when
+           selecting another one */
+        if (pick_cnt > 1 && iflags.getloc_filter == gf)
+            iflags.getloc_filter = (window_pick[1].item.a_char - 1);
+        free((genericptr_t) window_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("msg_window", optname)) {
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
+    if (WINDOWPORT("tty") || WINDOWPORT("curses")) {
+        /* by Christian W. Cooper */
         menu_item *window_pick = (menu_item *) 0;
-        int pick_cnt;
-        char gf = iflags.getloc_filter;
 
         tmpwin = create_nhwindow(NHW_MENU);
         start_menu(tmpwin);
         any = zeroany;
-        any.a_char = (GFILTER_NONE + 1);
-        add_menu(tmpwin, NO_GLYPH, &any, 'n',
-                 0, ATR_NONE, "no filtering",
-                 (gf == GFILTER_NONE) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = (GFILTER_VIEW + 1);
-        add_menu(tmpwin, NO_GLYPH, &any, 'v',
-                 0, ATR_NONE, "in view only",
-                 (gf == GFILTER_VIEW) ? MENU_SELECTED : MENU_UNSELECTED);
-        any.a_char = (GFILTER_AREA + 1);
-        add_menu(tmpwin, NO_GLYPH, &any, 'a',
-                 0, ATR_NONE, "in same area",
-                 (gf == GFILTER_AREA) ? MENU_SELECTED : MENU_UNSELECTED);
-        end_menu(tmpwin,
-      "Select location filtering when going for next/previous map position:");
-        if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &window_pick)) > 0) {
-            iflags.getloc_filter = (window_pick[0].item.a_char - 1);
-            /* PICK_ONE doesn't unselect preselected entry when
-               selecting another one */
-            if (pick_cnt > 1 && iflags.getloc_filter == gf)
-                iflags.getloc_filter = (window_pick[1].item.a_char - 1);
+        if (!WINDOWPORT("curses")) {
+            any.a_char = 's';
+            add_menu(tmpwin, NO_GLYPH, &any, 's', 0, ATR_NONE,
+                     "single", MENU_UNSELECTED);
+            any.a_char = 'c';
+            add_menu(tmpwin, NO_GLYPH, &any, 'c', 0, ATR_NONE,
+                     "combination", MENU_UNSELECTED);
+        }
+        any.a_char = 'f';
+        add_menu(tmpwin, NO_GLYPH, &any, 'f', 0, ATR_NONE, "full",
+                 MENU_UNSELECTED);
+        any.a_char = 'r';
+        add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "reversed",
+                 MENU_UNSELECTED);
+        end_menu(tmpwin, "Select message history display type:");
+        if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
+            iflags.prevmsg_window = window_pick->item.a_char;
             free((genericptr_t) window_pick);
         }
         destroy_nhwindow(tmpwin);
-    } else if (!strcmp("msg_window", optname)) {
-#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
-        if (WINDOWPORT("tty") || WINDOWPORT("curses")) {
-            /* by Christian W. Cooper */
-            menu_item *window_pick = (menu_item *) 0;
-
-            tmpwin = create_nhwindow(NHW_MENU);
-            start_menu(tmpwin);
-            any = zeroany;
-            if (!WINDOWPORT("curses")) {
-                any.a_char = 's';
-                add_menu(tmpwin, NO_GLYPH, &any, 's', 0, ATR_NONE,
-                         "single", MENU_UNSELECTED);
-                any.a_char = 'c';
-                add_menu(tmpwin, NO_GLYPH, &any, 'c', 0, ATR_NONE,
-                         "combination", MENU_UNSELECTED);
-            }
-            any.a_char = 'f';
-            add_menu(tmpwin, NO_GLYPH, &any, 'f', 0, ATR_NONE, "full",
-                     MENU_UNSELECTED);
-            any.a_char = 'r';
-            add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "reversed",
-                     MENU_UNSELECTED);
-            end_menu(tmpwin, "Select message history display type:");
-            if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
-                iflags.prevmsg_window = window_pick->item.a_char;
-                free((genericptr_t) window_pick);
-            }
-            destroy_nhwindow(tmpwin);
-        } else
+    } else
 #endif /* msg_window for tty or curses */
-            pline("'%s' option is not supported for '%s'.",
-                  optname, windowprocs.name);
-    } else if (!strcmp("sortloot", optname)) {
-        const char *sortl_name;
-        menu_item *sortl_pick = (menu_item *) 0;
+        pline("'%s' option is not supported for '%s'.",
+              optname, windowprocs.name);
+} else if (!strcmp("sortloot", optname)) {
+    const char *sortl_name;
+    menu_item *sortl_pick = (menu_item *) 0;
 
-        tmpwin = create_nhwindow(NHW_MENU);
-        start_menu(tmpwin);
-        any = zeroany;
-        for (i = 0; i < SIZE(sortltype); i++) {
-            sortl_name = sortltype[i];
-            any.a_char = *sortl_name;
-            add_menu(tmpwin, NO_GLYPH, &any, *sortl_name, 0, ATR_NONE,
-                     sortl_name, (flags.sortloot == *sortl_name)
-                                    ? MENU_SELECTED : MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Select loot sorting type:");
-        n = select_menu(tmpwin, PICK_ONE, &sortl_pick);
-        if (n > 0) {
-            char c = sortl_pick[0].item.a_char;
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < SIZE(sortltype); i++) {
+        sortl_name = sortltype[i];
+        any.a_char = *sortl_name;
+        add_menu(tmpwin, NO_GLYPH, &any, *sortl_name, 0, ATR_NONE,
+                 sortl_name, (flags.sortloot == *sortl_name)
+                                ? MENU_SELECTED : MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Select loot sorting type:");
+    n = select_menu(tmpwin, PICK_ONE, &sortl_pick);
+    if (n > 0) {
+        char c = sortl_pick[0].item.a_char;
+
+        if (n > 1 && c == flags.sortloot)
+            c = sortl_pick[1].item.a_char;
+        flags.sortloot = c;
+        free((genericptr_t) sortl_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("align_message", optname)
+           || !strcmp("align_status", optname)) {
+    menu_item *window_pick = (menu_item *) 0;
+    char abuf[BUFSZ];
+    boolean msg = (*(optname + 6) == 'm');
+
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    any.a_int = ALIGN_TOP;
+    add_menu(tmpwin, NO_GLYPH, &any, 't', 0, ATR_NONE, "top",
+             MENU_UNSELECTED);
+    any.a_int = ALIGN_BOTTOM;
+    add_menu(tmpwin, NO_GLYPH, &any, 'b', 0, ATR_NONE, "bottom",
+             MENU_UNSELECTED);
+    any.a_int = ALIGN_LEFT;
+    add_menu(tmpwin, NO_GLYPH, &any, 'l', 0, ATR_NONE, "left",
+             MENU_UNSELECTED);
+    any.a_int = ALIGN_RIGHT;
+    add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "right",
+             MENU_UNSELECTED);
+    Sprintf(abuf, "Select %s window placement relative to the map:",
+            msg ? "message" : "status");
+    end_menu(tmpwin, abuf);
+    if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
+        if (msg)
+            iflags.wc_align_message = window_pick->item.a_int;
+        else
+            iflags.wc_align_status = window_pick->item.a_int;
+        free((genericptr_t) window_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("number_pad", optname)) {
+    static const char *npchoices[] = {
+        " 0 (off)", " 1 (on)", " 2 (on, MSDOS compatible)",
+        " 3 (on, phone-style digit layout)",
+        " 4 (on, phone-style layout, MSDOS compatible)",
+        "-1 (off, 'z' to move upper-left, 'y' to zap wands)"
+    };
+    menu_item *mode_pick = (menu_item *) 0;
 
-            if (n > 1 && c == flags.sortloot)
-                c = sortl_pick[1].item.a_char;
-            flags.sortloot = c;
-            free((genericptr_t) sortl_pick);
+    tmpwin = create_nhwindow(NHW_MENU);
+    start_menu(tmpwin);
+    any = zeroany;
+    for (i = 0; i < SIZE(npchoices); i++) {
+        any.a_int = i + 1;
+        add_menu(tmpwin, NO_GLYPH, &any, 'a' + i, 0, ATR_NONE,
+                 npchoices[i], MENU_UNSELECTED);
+    }
+    end_menu(tmpwin, "Select number_pad mode:");
+    if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
+        switch (mode_pick->item.a_int - 1) {
+        case 0:
+            iflags.num_pad = FALSE;
+            iflags.num_pad_mode = 0;
+            break;
+        case 1:
+            iflags.num_pad = TRUE;
+            iflags.num_pad_mode = 0;
+            break;
+        case 2:
+            iflags.num_pad = TRUE;
+            iflags.num_pad_mode = 1;
+            break;
+        case 3:
+            iflags.num_pad = TRUE;
+            iflags.num_pad_mode = 2;
+            break;
+        case 4:
+            iflags.num_pad = TRUE;
+            iflags.num_pad_mode = 3;
+            break;
+        /* last menu choice: number_pad == -1 */
+        case 5:
+            iflags.num_pad = FALSE;
+            iflags.num_pad_mode = 1;
+            break;
         }
-        destroy_nhwindow(tmpwin);
-    } else if (!strcmp("align_message", optname)
-               || !strcmp("align_status", optname)) {
-        menu_item *window_pick = (menu_item *) 0;
-        char abuf[BUFSZ];
-        boolean msg = (*(optname + 6) == 'm');
+        reset_commands(FALSE);
+        number_pad(iflags.num_pad ? 1 : 0);
+        free((genericptr_t) mode_pick);
+    }
+    destroy_nhwindow(tmpwin);
+} else if (!strcmp("menu_headings", optname)) {
+    int mhattr = query_attr("How to highlight menu headings:");
+
+    if (mhattr != -1)
+        iflags.menu_headings = mhattr;
+} else if (!strcmp("msgtype", optname)) {
+    int opt_idx, nmt, mttyp;
+    char mtbuf[BUFSZ];
+
+msgtypes_again:
+    nmt = msgtype_count();
+    opt_idx = handle_add_list_remove("message type", nmt);
+    if (opt_idx == 3) { /* done */
+        return TRUE;
+    } else if (opt_idx == 0) { /* add new */
+        mtbuf[0] = '\0';
+        getlin("What new message pattern?", mtbuf);
+        if (*mtbuf == '\033')
+            return TRUE;
+        if (*mtbuf
+            && test_regex_pattern(mtbuf, (const char *)0)
+            && (mttyp = query_msgtype()) != -1
+            && !msgtype_add(mttyp, mtbuf)) {
+            pline("Error adding the message type.");
+            wait_synch();
+        }
+        goto msgtypes_again;
+    } else { /* list (1) or remove (2) */
+        int pick_idx, pick_cnt;
+        int mt_idx;
+        unsigned ln;
+        const char *mtype;
+        menu_item *pick_list = (menu_item *) 0;
+        struct plinemsg_type *tmp = plinemsg_types;
 
         tmpwin = create_nhwindow(NHW_MENU);
         start_menu(tmpwin);
         any = zeroany;
-        any.a_int = ALIGN_TOP;
-        add_menu(tmpwin, NO_GLYPH, &any, 't', 0, ATR_NONE, "top",
-                 MENU_UNSELECTED);
-        any.a_int = ALIGN_BOTTOM;
-        add_menu(tmpwin, NO_GLYPH, &any, 'b', 0, ATR_NONE, "bottom",
-                 MENU_UNSELECTED);
-        any.a_int = ALIGN_LEFT;
-        add_menu(tmpwin, NO_GLYPH, &any, 'l', 0, ATR_NONE, "left",
-                 MENU_UNSELECTED);
-        any.a_int = ALIGN_RIGHT;
-        add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "right",
-                 MENU_UNSELECTED);
-        Sprintf(abuf, "Select %s window placement relative to the map:",
-                msg ? "message" : "status");
-        end_menu(tmpwin, abuf);
-        if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
-            if (msg)
-                iflags.wc_align_message = window_pick->item.a_int;
+        mt_idx = 0;
+        while (tmp) {
+            mtype = msgtype2name(tmp->msgtype);
+            any.a_int = ++mt_idx;
+            Sprintf(mtbuf, "%-5s \"", mtype);
+            ln = sizeof mtbuf - strlen(mtbuf) - sizeof "\"";
+            if (strlen(tmp->pattern) > ln)
+                Strcat(strncat(mtbuf, tmp->pattern, ln - 3), "...\"");
             else
-                iflags.wc_align_status = window_pick->item.a_int;
-            free((genericptr_t) window_pick);
+                Strcat(strcat(mtbuf, tmp->pattern), "\"");
+            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, mtbuf,
+                     MENU_UNSELECTED);
+            tmp = tmp->next;
+        }
+        Sprintf(mtbuf, "%s message types",
+                (opt_idx == 1) ? "List of" : "Remove which");
+        end_menu(tmpwin, mtbuf);
+        pick_cnt = select_menu(tmpwin,
+                               (opt_idx == 1) ? PICK_NONE : PICK_ANY,
+                               &pick_list);
+        if (pick_cnt > 0) {
+            for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
+                free_one_msgtype(pick_list[pick_idx].item.a_int - 1
+                                       - pick_idx);
+            free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
         }
         destroy_nhwindow(tmpwin);
-    } else if (!strcmp("number_pad", optname)) {
-        static const char *npchoices[] = {
-            " 0 (off)", " 1 (on)", " 2 (on, MSDOS compatible)",
-            " 3 (on, phone-style digit layout)",
-            " 4 (on, phone-style layout, MSDOS compatible)",
-            "-1 (off, 'z' to move upper-left, 'y' to zap wands)"
-        };
-        menu_item *mode_pick = (menu_item *) 0;
+        if (pick_cnt >= 0)
+            goto msgtypes_again;
+    }
+} else if (!strcmp("menu_colors", optname)) {
+    int opt_idx, nmc, mcclr, mcattr;
+    char mcbuf[BUFSZ];
+
+menucolors_again:
+    nmc = count_menucolors();
+    opt_idx = handle_add_list_remove("menucolor", nmc);
+    if (opt_idx == 3) { /* done */
+menucolors_done:
+        /* in case we've made a change which impacts current persistent
+           inventory window; we don't track whether an actual changed
+           occurred, so just assume there was one and that it matters;
+           if we're wrong, a redundant update is cheap... */
+        if (iflags.use_menu_color)
+            update_inventory();
+
+        /* menu colors aren't being used; if any are defined, remind
+           player how to use them */
+        else if (nmc > 0)
+            pline(
+"To have menu colors become active, toggle 'menucolors' option to True.");
+        return TRUE;
+
+    } else if (opt_idx == 0) { /* add new */
+        mcbuf[0] = '\0';
+        getlin("What new menucolor pattern?", mcbuf);
+        if (*mcbuf == '\033')
+            goto menucolors_done;
+        if (*mcbuf
+            && test_regex_pattern(mcbuf, (const char *)0)
+            && (mcclr = query_color((char *) 0)) != -1
+            && (mcattr = query_attr((char *) 0)) != -1
+            && !add_menu_coloring_parsed(mcbuf, mcclr, mcattr)) {
+            pline("Error adding the menu color.");
+            wait_synch();
+        }
+        goto menucolors_again;
+
+    } else { /* list (1) or remove (2) */
+        int pick_idx, pick_cnt;
+        int mc_idx;
+        unsigned ln;
+        const char *sattr, *sclr;
+        menu_item *pick_list = (menu_item *) 0;
+        struct menucoloring *tmp = menu_colorings;
+        char clrbuf[QBUFSZ];
 
         tmpwin = create_nhwindow(NHW_MENU);
         start_menu(tmpwin);
         any = zeroany;
-        for (i = 0; i < SIZE(npchoices); i++) {
-            any.a_int = i + 1;
-            add_menu(tmpwin, NO_GLYPH, &any, 'a' + i, 0, ATR_NONE,
-                     npchoices[i], MENU_UNSELECTED);
-        }
-        end_menu(tmpwin, "Select number_pad mode:");
-        if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
-            switch (mode_pick->item.a_int - 1) {
-            case 0:
-                iflags.num_pad = FALSE;
-                iflags.num_pad_mode = 0;
-                break;
-            case 1:
-                iflags.num_pad = TRUE;
-                iflags.num_pad_mode = 0;
-                break;
-            case 2:
-                iflags.num_pad = TRUE;
-                iflags.num_pad_mode = 1;
-                break;
-            case 3:
-                iflags.num_pad = TRUE;
-                iflags.num_pad_mode = 2;
-                break;
-            case 4:
-                iflags.num_pad = TRUE;
-                iflags.num_pad_mode = 3;
-                break;
-            /* last menu choice: number_pad == -1 */
-            case 5:
-                iflags.num_pad = FALSE;
-                iflags.num_pad_mode = 1;
-                break;
-            }
-            reset_commands(FALSE);
-            number_pad(iflags.num_pad ? 1 : 0);
-            free((genericptr_t) mode_pick);
+        mc_idx = 0;
+        while (tmp) {
+            sattr = attr2attrname(tmp->attr);
+            sclr = strcpy(clrbuf, clr2colorname(tmp->color));
+            (void) strNsubst(clrbuf, " ", "-", 0);
+            any.a_int = ++mc_idx;
+            /* construct suffix */
+            Sprintf(buf, "\"\"=%s%s%s", sclr,
+                    (tmp->attr != ATR_NONE) ? "&" : "",
+                    (tmp->attr != ATR_NONE) ? sattr : "");
+            /* now main string */
+            ln = sizeof buf - strlen(buf) - 1; /* length available */
+            Strcpy(mcbuf, "\"");
+            if (strlen(tmp->origstr) > ln)
+                Strcat(strncat(mcbuf, tmp->origstr, ln - 3), "...");
+            else
+                Strcat(mcbuf, tmp->origstr);
+            /* combine main string and suffix */
+            Strcat(mcbuf, &buf[1]); /* skip buf[]'s initial quote */
+            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, mcbuf,
+                     MENU_UNSELECTED);
+            tmp = tmp->next;
+        }
+        Sprintf(mcbuf, "%s menu colors",
+                (opt_idx == 1) ? "List of" : "Remove which");
+        end_menu(tmpwin, mcbuf);
+        pick_cnt = select_menu(tmpwin,
+                               (opt_idx == 1) ? PICK_NONE : PICK_ANY,
+                               &pick_list);
+        if (pick_cnt > 0) {
+            for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
+                free_one_menu_coloring(pick_list[pick_idx].item.a_int - 1
+                                       - pick_idx);
+            free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
         }
         destroy_nhwindow(tmpwin);
-    } else if (!strcmp("menu_headings", optname)) {
-        int mhattr = query_attr("How to highlight menu headings:");
+        if (pick_cnt >= 0)
+            goto menucolors_again;
+    }
+} else if (!strcmp("autopickup_exception", optname)) {
+    int opt_idx, numapes = 0;
+    char apebuf[2 + BUFSZ]; /* so &apebuf[1] is BUFSZ long for getlin() */
+    struct autopickup_exception *ape;
 
-        if (mhattr != -1)
-            iflags.menu_headings = mhattr;
-    } else if (!strcmp("msgtype", optname)) {
-        int opt_idx, nmt, mttyp;
-        char mtbuf[BUFSZ];
-
- msgtypes_again:
-        nmt = msgtype_count();
-        opt_idx = handle_add_list_remove("message type", nmt);
-        if (opt_idx == 3) { /* done */
+ape_again:
+    numapes = count_apes();
+    opt_idx = handle_add_list_remove("autopickup exception", numapes);
+    if (opt_idx == 3) { /* done */
+        return TRUE;
+    } else if (opt_idx == 0) { /* add new */
+        /* EDIT_GETLIN:  assume user doesn't user want previous
+           exception used as default input string for this one... */
+        apebuf[0] = apebuf[1] = '\0';
+        getlin("What new autopickup exception pattern?", &apebuf[1]);
+        mungspaces(&apebuf[1]); /* regularize whitespace */
+        if (apebuf[1] == '\033')
             return TRUE;
-        } else if (opt_idx == 0) { /* add new */
-            mtbuf[0] = '\0';
-            getlin("What new message pattern?", mtbuf);
-            if (*mtbuf == '\033')
-                return TRUE;
-            if (*mtbuf
-                && test_regex_pattern(mtbuf, (const char *)0)
-                && (mttyp = query_msgtype()) != -1
-                && !msgtype_add(mttyp, mtbuf)) {
-                pline("Error adding the message type.");
-                wait_synch();
-            }
-            goto msgtypes_again;
-        } else { /* list (1) or remove (2) */
-            int pick_idx, pick_cnt;
-            int mt_idx;
-            unsigned ln;
-            const char *mtype;
-            menu_item *pick_list = (menu_item *) 0;
-            struct plinemsg_type *tmp = plinemsg_types;
+        if (apebuf[1]) {
+            apebuf[0] = '\"';
+            /* guarantee room for \" prefix and \"\0 suffix;
+               -2 is good enough for apebuf[] but -3 makes
+               sure the whole thing fits within normal BUFSZ */
+            apebuf[sizeof apebuf - 2] = '\0';
+            Strcat(apebuf, "\"");
+            add_autopickup_exception(apebuf);
+        }
+        goto ape_again;
+    } else { /* list (1) or remove (2) */
+        int pick_idx, pick_cnt;
+        menu_item *pick_list = (menu_item *) 0;
 
-            tmpwin = create_nhwindow(NHW_MENU);
-            start_menu(tmpwin);
+        tmpwin = create_nhwindow(NHW_MENU);
+        start_menu(tmpwin);
+        if (numapes) {
+            ape = apelist;
             any = zeroany;
-            mt_idx = 0;
-            while (tmp) {
-                mtype = msgtype2name(tmp->msgtype);
-                any.a_int = ++mt_idx;
-                Sprintf(mtbuf, "%-5s \"", mtype);
-                ln = sizeof mtbuf - strlen(mtbuf) - sizeof "\"";
-                if (strlen(tmp->pattern) > ln)
-                    Strcat(strncat(mtbuf, tmp->pattern, ln - 3), "...\"");
-                else
-                    Strcat(strcat(mtbuf, tmp->pattern), "\"");
-                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, mtbuf,
+            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+                     "Always pickup '<'; never pickup '>'",
+                     MENU_UNSELECTED);
+            for (i = 0; i < numapes && ape; i++) {
+                any.a_void = (opt_idx == 1) ? 0 : ape;
+                /* length of pattern plus quotes (plus '<'/'>') is
+                   less than BUFSZ */
+                Sprintf(apebuf, "\"%c%s\"", ape->grab ? '<' : '>',
+                        ape->pattern);
+                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, apebuf,
                          MENU_UNSELECTED);
-                tmp = tmp->next;
+                ape = ape->next;
             }
-            Sprintf(mtbuf, "%s message types",
-                    (opt_idx == 1) ? "List of" : "Remove which");
-            end_menu(tmpwin, mtbuf);
-            pick_cnt = select_menu(tmpwin,
-                                   (opt_idx == 1) ? PICK_NONE : PICK_ANY,
-                                   &pick_list);
-            if (pick_cnt > 0) {
-                for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
-                    free_one_msgtype(pick_list[pick_idx].item.a_int - 1
-                                           - pick_idx);
-                free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
-            }
-            destroy_nhwindow(tmpwin);
-            if (pick_cnt >= 0)
-                goto msgtypes_again;
         }
-    } else if (!strcmp("menu_colors", optname)) {
-        int opt_idx, nmc, mcclr, mcattr;
-        char mcbuf[BUFSZ];
-
- menucolors_again:
-        nmc = count_menucolors();
-        opt_idx = handle_add_list_remove("menucolor", nmc);
-        if (opt_idx == 3) { /* done */
- menucolors_done:
-            /* in case we've made a change which impacts current persistent
-               inventory window; we don't track whether an actual changed
-               occurred, so just assume there was one and that it matters;
-               if we're wrong, a redundant update is cheap... */
-            if (iflags.use_menu_color)
-                update_inventory();
-
-            /* menu colors aren't being used; if any are defined, remind
-               player how to use them */
-            else if (nmc > 0)
-                pline(
-    "To have menu colors become active, toggle 'menucolors' option to True.");
-            return TRUE;
-
-        } else if (opt_idx == 0) { /* add new */
-            mcbuf[0] = '\0';
-            getlin("What new menucolor pattern?", mcbuf);
-            if (*mcbuf == '\033')
-                goto menucolors_done;
-            if (*mcbuf
-                && test_regex_pattern(mcbuf, (const char *)0)
-                && (mcclr = query_color((char *) 0)) != -1
-                && (mcattr = query_attr((char *) 0)) != -1
-                && !add_menu_coloring_parsed(mcbuf, mcclr, mcattr)) {
-                pline("Error adding the menu color.");
-                wait_synch();
-            }
-            goto menucolors_again;
-
-        } else { /* list (1) or remove (2) */
-            int pick_idx, pick_cnt;
-            int mc_idx;
-            unsigned ln;
-            const char *sattr, *sclr;
-            menu_item *pick_list = (menu_item *) 0;
-            struct menucoloring *tmp = menu_colorings;
-            char clrbuf[QBUFSZ];
-
-            tmpwin = create_nhwindow(NHW_MENU);
-            start_menu(tmpwin);
-            any = zeroany;
-            mc_idx = 0;
-            while (tmp) {
-                sattr = attr2attrname(tmp->attr);
-                sclr = strcpy(clrbuf, clr2colorname(tmp->color));
-                (void) strNsubst(clrbuf, " ", "-", 0);
-                any.a_int = ++mc_idx;
-                /* construct suffix */
-                Sprintf(buf, "\"\"=%s%s%s", sclr,
-                        (tmp->attr != ATR_NONE) ? "&" : "",
-                        (tmp->attr != ATR_NONE) ? sattr : "");
-                /* now main string */
-                ln = sizeof buf - strlen(buf) - 1; /* length available */
-                Strcpy(mcbuf, "\"");
-                if (strlen(tmp->origstr) > ln)
-                    Strcat(strncat(mcbuf, tmp->origstr, ln - 3), "...");
-                else
-                    Strcat(mcbuf, tmp->origstr);
-                /* combine main string and suffix */
-                Strcat(mcbuf, &buf[1]); /* skip buf[]'s initial quote */
-                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, mcbuf,
-                         MENU_UNSELECTED);
-                tmp = tmp->next;
-            }
-            Sprintf(mcbuf, "%s menu colors",
-                    (opt_idx == 1) ? "List of" : "Remove which");
-            end_menu(tmpwin, mcbuf);
-            pick_cnt = select_menu(tmpwin,
-                                   (opt_idx == 1) ? PICK_NONE : PICK_ANY,
-                                   &pick_list);
-            if (pick_cnt > 0) {
-                for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
-                    free_one_menu_coloring(pick_list[pick_idx].item.a_int - 1
-                                           - pick_idx);
-                free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
-            }
-            destroy_nhwindow(tmpwin);
-            if (pick_cnt >= 0)
-                goto menucolors_again;
+        Sprintf(apebuf, "%s autopickup exceptions",
+                (opt_idx == 1) ? "List of" : "Remove which");
+        end_menu(tmpwin, apebuf);
+        pick_cnt = select_menu(tmpwin,
+                               (opt_idx == 1) ? PICK_NONE : PICK_ANY,
+                               &pick_list);
+        if (pick_cnt > 0) {
+            for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
+                remove_autopickup_exception(
+                                     (struct autopickup_exception *)
+                                         pick_list[pick_idx].item.a_void);
+            free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
         }
-    } else if (!strcmp("autopickup_exception", optname)) {
-        int opt_idx, numapes = 0;
-        char apebuf[2 + BUFSZ]; /* so &apebuf[1] is BUFSZ long for getlin() */
-        struct autopickup_exception *ape;
-
- ape_again:
-        numapes = count_apes();
-        opt_idx = handle_add_list_remove("autopickup exception", numapes);
-        if (opt_idx == 3) { /* done */
-            return TRUE;
-        } else if (opt_idx == 0) { /* add new */
-            /* EDIT_GETLIN:  assume user doesn't user want previous
-               exception used as default input string for this one... */
-            apebuf[0] = apebuf[1] = '\0';
-            getlin("What new autopickup exception pattern?", &apebuf[1]);
-            mungspaces(&apebuf[1]); /* regularize whitespace */
-            if (apebuf[1] == '\033')
-                return TRUE;
-            if (apebuf[1]) {
-                apebuf[0] = '\"';
-                /* guarantee room for \" prefix and \"\0 suffix;
-                   -2 is good enough for apebuf[] but -3 makes
-                   sure the whole thing fits within normal BUFSZ */
-                apebuf[sizeof apebuf - 2] = '\0';
-                Strcat(apebuf, "\"");
-                add_autopickup_exception(apebuf);
-            }
+        destroy_nhwindow(tmpwin);
+        if (pick_cnt >= 0)
             goto ape_again;
-        } else { /* list (1) or remove (2) */
-            int pick_idx, pick_cnt;
-            menu_item *pick_list = (menu_item *) 0;
-
-            tmpwin = create_nhwindow(NHW_MENU);
-            start_menu(tmpwin);
-            if (numapes) {
-                ape = apelist;
-                any = zeroany;
-                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-                         "Always pickup '<'; never pickup '>'",
-                         MENU_UNSELECTED);
-                for (i = 0; i < numapes && ape; i++) {
-                    any.a_void = (opt_idx == 1) ? 0 : ape;
-                    /* length of pattern plus quotes (plus '<'/'>') is
-                       less than BUFSZ */
-                    Sprintf(apebuf, "\"%c%s\"", ape->grab ? '<' : '>',
-                            ape->pattern);
-                    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, apebuf,
-                             MENU_UNSELECTED);
-                    ape = ape->next;
-                }
-            }
-            Sprintf(apebuf, "%s autopickup exceptions",
-                    (opt_idx == 1) ? "List of" : "Remove which");
-            end_menu(tmpwin, apebuf);
-            pick_cnt = select_menu(tmpwin,
-                                   (opt_idx == 1) ? PICK_NONE : PICK_ANY,
-                                   &pick_list);
-            if (pick_cnt > 0) {
-                for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
-                    remove_autopickup_exception(
-                                         (struct autopickup_exception *)
-                                             pick_list[pick_idx].item.a_void);
-                free((genericptr_t) pick_list), pick_list = (menu_item *) 0;
-            }
-            destroy_nhwindow(tmpwin);
-            if (pick_cnt >= 0)
-                goto ape_again;
-        }
-    } else if (!strcmp("symset", optname)
-               || !strcmp("roguesymset", optname)) {
-        menu_item *symset_pick = (menu_item *) 0;
-        boolean rogueflag = (*optname == 'r'),
-                ready_to_switch = FALSE,
-                nothing_to_do = FALSE;
-        char *symset_name, fmtstr[20];
-        struct symsetentry *sl;
-        int res, which_set, setcount = 0, chosen = -2, defindx = 0;
-
-        which_set = rogueflag ? ROGUESET : PRIMARY;
-        symset_list = (struct symsetentry *) 0;
-        /* clear symset[].name as a flag to read_sym_file() to build list */
-        symset_name = symset[which_set].name;
-        symset[which_set].name = (char *) 0;
-
-        res = read_sym_file(which_set);
-        /* put symset name back */
-        symset[which_set].name = symset_name;
-
-        if (res && symset_list) {
-            int thissize,
-                biggest = (int) (sizeof "Default Symbols" - sizeof ""),
-                big_desc = 0;
-
-            for (sl = symset_list; sl; sl = sl->next) {
-                /* check restrictions */
-                if (rogueflag ? sl->primary : sl->rogue)
-                    continue;
+    }
+} else if (!strcmp("symset", optname)
+           || !strcmp("roguesymset", optname)) {
+    menu_item *symset_pick = (menu_item *) 0;
+    boolean rogueflag = (*optname == 'r'),
+            ready_to_switch = FALSE,
+            nothing_to_do = FALSE;
+    char *symset_name, fmtstr[20];
+    struct symsetentry *sl;
+    int res, which_set, setcount = 0, chosen = -2, defindx = 0;
+
+    which_set = rogueflag ? ROGUESET : PRIMARY;
+    symset_list = (struct symsetentry *) 0;
+    /* clear symset[].name as a flag to read_sym_file() to build list */
+    symset_name = symset[which_set].name;
+    symset[which_set].name = (char *) 0;
+
+    res = read_sym_file(which_set);
+    /* put symset name back */
+    symset[which_set].name = symset_name;
+
+    if (res && symset_list) {
+        int thissize,
+            biggest = (int) (sizeof "Default Symbols" - sizeof ""),
+            big_desc = 0;
+
+        for (sl = symset_list; sl; sl = sl->next) {
+            /* check restrictions */
+            if (rogueflag ? sl->primary : sl->rogue)
+                continue;
 #ifndef MAC_GRAPHICS_ENV
-                if (sl->handling == H_MAC)
-                    continue;
+            if (sl->handling == H_MAC)
+                continue;
 #endif
 
-                setcount++;
-                /* find biggest name */
-                thissize = sl->name ? (int) strlen(sl->name) : 0;
-                if (thissize > biggest)
-                    biggest = thissize;
-                thissize = sl->desc ? (int) strlen(sl->desc) : 0;
-                if (thissize > big_desc)
-                    big_desc = thissize;
-            }
-            if (!setcount) {
-                pline("There are no appropriate %s symbol sets available.",
-                      rogueflag ? "rogue level" : "primary");
-                return TRUE;
-            }
+            setcount++;
+            /* find biggest name */
+            thissize = sl->name ? (int) strlen(sl->name) : 0;
+            if (thissize > biggest)
+                biggest = thissize;
+            thissize = sl->desc ? (int) strlen(sl->desc) : 0;
+            if (thissize > big_desc)
+                big_desc = thissize;
+        }
+        if (!setcount) {
+            pline("There are no appropriate %s symbol sets available.",
+                  rogueflag ? "rogue level" : "primary");
+            return TRUE;
+        }
 
-            Sprintf(fmtstr, "%%-%ds %%s", biggest + 2);
-            tmpwin = create_nhwindow(NHW_MENU);
-            start_menu(tmpwin);
-            any = zeroany;
-            any.a_int = 1; /* -1 + 2 [see 'if (sl->name) {' below]*/
-            if (!symset_name)
-                defindx = any.a_int;
-            add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE,
-                     "Default Symbols",
-                     (any.a_int == defindx) ? MENU_SELECTED
-                                            : MENU_UNSELECTED);
-
-            for (sl = symset_list; sl; sl = sl->next) {
-                /* check restrictions */
-                if (rogueflag ? sl->primary : sl->rogue)
-                    continue;
+        Sprintf(fmtstr, "%%-%ds %%s", biggest + 2);
+        tmpwin = create_nhwindow(NHW_MENU);
+        start_menu(tmpwin);
+        any = zeroany;
+        any.a_int = 1; /* -1 + 2 [see 'if (sl->name) {' below]*/
+        if (!symset_name)
+            defindx = any.a_int;
+        add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE,
+                 "Default Symbols",
+                 (any.a_int == defindx) ? MENU_SELECTED
+                                        : MENU_UNSELECTED);
+
+        for (sl = symset_list; sl; sl = sl->next) {
+            /* check restrictions */
+            if (rogueflag ? sl->primary : sl->rogue)
+                continue;
 #ifndef MAC_GRAPHICS_ENV
-                if (sl->handling == H_MAC)
-                    continue;
+            if (sl->handling == H_MAC)
+                continue;
 #endif
-                if (sl->name) {
-                    /* +2: sl->idx runs from 0 to N-1 for N symsets;
-                       +1 because Defaults are implicitly in slot [0];
-                       +1 again so that valid data is never 0 */
-                    any.a_int = sl->idx + 2;
-                    if (symset_name && !strcmpi(sl->name, symset_name))
-                        defindx = any.a_int;
-                    Sprintf(buf, fmtstr, sl->name, sl->desc ? sl->desc : "");
-                    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf,
-                             (any.a_int == defindx) ? MENU_SELECTED
-                                                    : MENU_UNSELECTED);
-                }
-            }
-            Sprintf(buf, "Select %ssymbol set:",
-                    rogueflag ? "rogue level " : "");
-            end_menu(tmpwin, buf);
-            n = select_menu(tmpwin, PICK_ONE, &symset_pick);
-            if (n > 0) {
-                chosen = symset_pick[0].item.a_int;
-                /* if picking non-preselected entry yields 2, make sure
-                   that we're going with the non-preselected one */
-                if (n == 2 && chosen == defindx)
-                    chosen = symset_pick[1].item.a_int;
-                chosen -= 2; /* convert menu index to symset index;
-                              * "Default symbols" have index -1 */
-                free((genericptr_t) symset_pick);
-            } else if (n == 0 && defindx > 0) {
-                chosen = defindx - 2;
+            if (sl->name) {
+                /* +2: sl->idx runs from 0 to N-1 for N symsets;
+                   +1 because Defaults are implicitly in slot [0];
+                   +1 again so that valid data is never 0 */
+                any.a_int = sl->idx + 2;
+                if (symset_name && !strcmpi(sl->name, symset_name))
+                    defindx = any.a_int;
+                Sprintf(buf, fmtstr, sl->name, sl->desc ? sl->desc : "");
+                add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf,
+                         (any.a_int == defindx) ? MENU_SELECTED
+                                                : MENU_UNSELECTED);
             }
-            destroy_nhwindow(tmpwin);
-
-            if (chosen > -1) {
-                /* chose an actual symset name from file */
-                for (sl = symset_list; sl; sl = sl->next)
-                    if (sl->idx == chosen)
-                        break;
-                if (sl) {
-                    /* free the now stale attributes */
-                    clear_symsetentry(which_set, TRUE);
-
-                    /* transfer only the name of the symbol set */
-                    symset[which_set].name = dupstr(sl->name);
-                    ready_to_switch = TRUE;
-                }
-            } else if (chosen == -1) {
-                /* explicit selection of defaults */
-                /* free the now stale symset attributes */
-                clear_symsetentry(which_set, TRUE);
-            } else
-                nothing_to_do = TRUE;
-        } else if (!res) {
-            /* The symbols file could not be accessed */
-            pline("Unable to access \"%s\" file.", SYMBOLS);
-            return TRUE;
-        } else if (!symset_list) {
-            /* The symbols file was empty */
-            pline("There were no symbol sets found in \"%s\".", SYMBOLS);
-            return TRUE;
         }
-
-        /* clean up */
-        while ((sl = symset_list) != 0) {
-            symset_list = sl->next;
-            if (sl->name)
-                free((genericptr_t) sl->name), sl->name = (char *) 0;
-            if (sl->desc)
-                free((genericptr_t) sl->desc), sl->desc = (char *) 0;
-            free((genericptr_t) sl);
+        Sprintf(buf, "Select %ssymbol set:",
+                rogueflag ? "rogue level " : "");
+        end_menu(tmpwin, buf);
+        n = select_menu(tmpwin, PICK_ONE, &symset_pick);
+        if (n > 0) {
+            chosen = symset_pick[0].item.a_int;
+            /* if picking non-preselected entry yields 2, make sure
+               that we're going with the non-preselected one */
+            if (n == 2 && chosen == defindx)
+                chosen = symset_pick[1].item.a_int;
+            chosen -= 2; /* convert menu index to symset index;
+                          * "Default symbols" have index -1 */
+            free((genericptr_t) symset_pick);
+        } else if (n == 0 && defindx > 0) {
+            chosen = defindx - 2;
         }
+        destroy_nhwindow(tmpwin);
 
-        if (nothing_to_do)
-            return TRUE;
-
-        /* Set default symbols and clear the handling value */
-        if (rogueflag)
-            init_rogue_symbols();
-        else
-            init_primary_symbols();
+        if (chosen > -1) {
+            /* chose an actual symset name from file */
+            for (sl = symset_list; sl; sl = sl->next)
+                if (sl->idx == chosen)
+                    break;
+            if (sl) {
+                /* free the now stale attributes */
+                clear_symsetentry(which_set, TRUE);
 
-        if (symset[which_set].name) {
-            /* non-default symbols */
-            if (read_sym_file(which_set)) {
+                /* transfer only the name of the symbol set */
+                symset[which_set].name = dupstr(sl->name);
                 ready_to_switch = TRUE;
-            } else {
-                clear_symsetentry(which_set, TRUE);
-                return TRUE;
             }
-        }
+        } else if (chosen == -1) {
+            /* explicit selection of defaults */
+            /* free the now stale symset attributes */
+            clear_symsetentry(which_set, TRUE);
+        } else
+            nothing_to_do = TRUE;
+    } else if (!res) {
+        /* The symbols file could not be accessed */
+        pline("Unable to access \"%s\" file.", SYMBOLS);
+        return TRUE;
+    } else if (!symset_list) {
+        /* The symbols file was empty */
+        pline("There were no symbol sets found in \"%s\".", SYMBOLS);
+        return TRUE;
+    }
+
+    /* clean up */
+    while ((sl = symset_list) != 0) {
+        symset_list = sl->next;
+        if (sl->name)
+            free((genericptr_t) sl->name), sl->name = (char *) 0;
+        if (sl->desc)
+            free((genericptr_t) sl->desc), sl->desc = (char *) 0;
+        free((genericptr_t) sl);
+    }
 
-        if (ready_to_switch)
-            switch_symbols(TRUE);
+    if (nothing_to_do)
+        return TRUE;
 
-        if (Is_rogue_level(&u.uz)) {
-            if (rogueflag)
-                assign_graphics(ROGUESET);
-        } else if (!rogueflag)
-            assign_graphics(PRIMARY);
-        preference_update("symset");
-        need_redraw = TRUE;
+    /* Set default symbols and clear the handling value */
+    if (rogueflag)
+        init_rogue_symbols();
+    else
+        init_primary_symbols();
 
-    } else {
-        /* didn't match any of the special options */
-        return FALSE;
+    if (symset[which_set].name) {
+        /* non-default symbols */
+        if (read_sym_file(which_set)) {
+            ready_to_switch = TRUE;
+        } else {
+            clear_symsetentry(which_set, TRUE);
+            return TRUE;
+        }
     }
-    return TRUE;
+
+    if (ready_to_switch)
+        switch_symbols(TRUE);
+
+    if (Is_rogue_level(&u.uz)) {
+        if (rogueflag)
+            assign_graphics(ROGUESET);
+    } else if (!rogueflag)
+        assign_graphics(PRIMARY);
+    preference_update("symset");
+    need_redraw = TRUE;
+
+} else {
+    /* didn't match any of the special options */
+    return FALSE;
+}
+return TRUE;
 }
 
 #define rolestring(val, array, field) \
-    ((val >= 0) ? array[val].field : (val == ROLE_RANDOM) ? randomrole : none)
+((val >= 0) ? array[val].field : (val == ROLE_RANDOM) ? randomrole : none)
 
 /* This is ugly. We have all the option names in the compopt[] array,
-   but we need to look at each option individually to get the value. */
+but we need to look at each option individually to get the value. */
 STATIC_OVL const char *
 get_compopt_value(optname, buf)
 const char *optname;
 char *buf;
 {
-    static const char none[] = "(none)", randomrole[] = "random",
-                      to_be_done[] = "(to be done)",
-                      defopt[] = "default", defbrief[] = "def";
-    char ocl[MAXOCLASSES + 1];
-    int i;
-
-    buf[0] = '\0';
-    if (!strcmp(optname, "align_message")
-        || !strcmp(optname, "align_status")) {
-        int which = !strcmp(optname, "align_status") ? iflags.wc_align_status
-                                                     : iflags.wc_align_message;
-        Sprintf(buf, "%s",
-                (which == ALIGN_TOP) ? "top"
-                : (which == ALIGN_LEFT) ? "left"
-                  : (which == ALIGN_BOTTOM) ? "bottom"
-                    : (which == ALIGN_RIGHT) ? "right"
-                      : defopt);
-    } else if (!strcmp(optname, "align"))
-        Sprintf(buf, "%s", rolestring(flags.initalign, aligns, adj));
+static const char none[] = "(none)", randomrole[] = "random",
+                  to_be_done[] = "(to be done)",
+                  defopt[] = "default", defbrief[] = "def";
+char ocl[MAXOCLASSES + 1];
+int i;
+
+buf[0] = '\0';
+if (!strcmp(optname, "align_message")
+    || !strcmp(optname, "align_status")) {
+    int which = !strcmp(optname, "align_status") ? iflags.wc_align_status
+                                                 : iflags.wc_align_message;
+    Sprintf(buf, "%s",
+            (which == ALIGN_TOP) ? "top"
+            : (which == ALIGN_LEFT) ? "left"
+              : (which == ALIGN_BOTTOM) ? "bottom"
+                : (which == ALIGN_RIGHT) ? "right"
+                  : defopt);
+} else if (!strcmp(optname, "align"))
+    Sprintf(buf, "%s", rolestring(flags.initalign, aligns, adj));
 #ifdef WIN32
-    else if (!strcmp(optname, "altkeyhandler"))
-        Sprintf(buf, "%s",
-                iflags.altkeyhandler[0] ? iflags.altkeyhandler : "default");
+else if (!strcmp(optname, "altkeyhandler"))
+    Sprintf(buf, "%s",
+            iflags.altkeyhandler[0] ? iflags.altkeyhandler : "default");
 #endif
 #ifdef BACKWARD_COMPAT
-    else if (!strcmp(optname, "boulder"))
-        Sprintf(buf, "%c",
-                ov_primary_syms[SYM_BOULDER + SYM_OFF_X]
-                    ? ov_primary_syms[SYM_BOULDER + SYM_OFF_X]
-                    : showsyms[(int) objects[BOULDER].oc_class + SYM_OFF_O]);
-#endif
-    else if (!strcmp(optname, "catname"))
-        Sprintf(buf, "%s", catname[0] ? catname : none);
-    else if (!strcmp(optname, "disclose"))
-        for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
-            if (i)
-                (void) strkitten(buf, ' ');
-            (void) strkitten(buf, flags.end_disclose[i]);
-            (void) strkitten(buf, disclosure_options[i]);
-        }
-    else if (!strcmp(optname, "dogname"))
-        Sprintf(buf, "%s", dogname[0] ? dogname : none);
-    else if (!strcmp(optname, "dungeon"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "effects"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "font_map"))
-        Sprintf(buf, "%s", iflags.wc_font_map ? iflags.wc_font_map : defopt);
-    else if (!strcmp(optname, "font_message"))
-        Sprintf(buf, "%s",
-                iflags.wc_font_message ? iflags.wc_font_message : defopt);
-    else if (!strcmp(optname, "font_status"))
-        Sprintf(buf, "%s",
-                iflags.wc_font_status ? iflags.wc_font_status : defopt);
-    else if (!strcmp(optname, "font_menu"))
-        Sprintf(buf, "%s",
-                iflags.wc_font_menu ? iflags.wc_font_menu : defopt);
-    else if (!strcmp(optname, "font_text"))
-        Sprintf(buf, "%s",
-                iflags.wc_font_text ? iflags.wc_font_text : defopt);
-    else if (!strcmp(optname, "font_size_map")) {
-        if (iflags.wc_fontsiz_map)
-            Sprintf(buf, "%d", iflags.wc_fontsiz_map);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "font_size_message")) {
-        if (iflags.wc_fontsiz_message)
-            Sprintf(buf, "%d", iflags.wc_fontsiz_message);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "font_size_status")) {
-        if (iflags.wc_fontsiz_status)
-            Sprintf(buf, "%d", iflags.wc_fontsiz_status);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "font_size_menu")) {
-        if (iflags.wc_fontsiz_menu)
-            Sprintf(buf, "%d", iflags.wc_fontsiz_menu);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "font_size_text")) {
-        if (iflags.wc_fontsiz_text)
-            Sprintf(buf, "%d", iflags.wc_fontsiz_text);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "fruit"))
-        Sprintf(buf, "%s", pl_fruit);
-    else if (!strcmp(optname, "gender"))
-        Sprintf(buf, "%s", rolestring(flags.initgend, genders, adj));
-    else if (!strcmp(optname, "horsename"))
-        Sprintf(buf, "%s", horsename[0] ? horsename : none);
-    else if (!strcmp(optname, "map_mode")) {
-        i = iflags.wc_map_mode;
-        Sprintf(buf, "%s",
-                (i == MAP_MODE_TILES) ? "tiles"
-                : (i == MAP_MODE_ASCII4x6) ? "ascii4x6"
-                  : (i == MAP_MODE_ASCII6x8) ? "ascii6x8"
-                    : (i == MAP_MODE_ASCII8x8) ? "ascii8x8"
-                      : (i == MAP_MODE_ASCII16x8) ? "ascii16x8"
-                        : (i == MAP_MODE_ASCII7x12) ? "ascii7x12"
-                          : (i == MAP_MODE_ASCII8x12) ? "ascii8x12"
-                            : (i == MAP_MODE_ASCII16x12) ? "ascii16x12"
-                              : (i == MAP_MODE_ASCII12x16) ? "ascii12x16"
-                                : (i == MAP_MODE_ASCII10x18) ? "ascii10x18"
-                                  : (i == MAP_MODE_ASCII_FIT_TO_SCREEN)
-                                    ? "fit_to_screen"
-                                    : defopt);
-    } else if (!strcmp(optname, "menustyle"))
-        Sprintf(buf, "%s", menutype[(int) flags.menu_style]);
-    else if (!strcmp(optname, "menu_deselect_all"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_deselect_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_first_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_invert_all"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_headings"))
-        Sprintf(buf, "%s", attr2attrname(iflags.menu_headings));
-    else if (!strcmp(optname, "menu_invert_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_last_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_next_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_previous_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_search"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_select_all"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "menu_select_page"))
-        Sprintf(buf, "%s", to_be_done);
-    else if (!strcmp(optname, "monsters")) {
-        Sprintf(buf, "%s", to_be_done);
-    } else if (!strcmp(optname, "msghistory")) {
-        Sprintf(buf, "%u", iflags.msg_history);
+else if (!strcmp(optname, "boulder"))
+    Sprintf(buf, "%c",
+            ov_primary_syms[SYM_BOULDER + SYM_OFF_X]
+                ? ov_primary_syms[SYM_BOULDER + SYM_OFF_X]
+                : showsyms[(int) objects[BOULDER].oc_class + SYM_OFF_O]);
+#endif
+else if (!strcmp(optname, "catname"))
+    Sprintf(buf, "%s", catname[0] ? catname : none);
+else if (!strcmp(optname, "disclose"))
+    for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
+        if (i)
+            (void) strkitten(buf, ' ');
+        (void) strkitten(buf, flags.end_disclose[i]);
+        (void) strkitten(buf, disclosure_options[i]);
+    }
+else if (!strcmp(optname, "dogname"))
+    Sprintf(buf, "%s", dogname[0] ? dogname : none);
+else if (!strcmp(optname, "dungeon"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "effects"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "font_map"))
+    Sprintf(buf, "%s", iflags.wc_font_map ? iflags.wc_font_map : defopt);
+else if (!strcmp(optname, "font_message"))
+    Sprintf(buf, "%s",
+            iflags.wc_font_message ? iflags.wc_font_message : defopt);
+else if (!strcmp(optname, "font_status"))
+    Sprintf(buf, "%s",
+            iflags.wc_font_status ? iflags.wc_font_status : defopt);
+else if (!strcmp(optname, "font_menu"))
+    Sprintf(buf, "%s",
+            iflags.wc_font_menu ? iflags.wc_font_menu : defopt);
+else if (!strcmp(optname, "font_text"))
+    Sprintf(buf, "%s",
+            iflags.wc_font_text ? iflags.wc_font_text : defopt);
+else if (!strcmp(optname, "font_size_map")) {
+    if (iflags.wc_fontsiz_map)
+        Sprintf(buf, "%d", iflags.wc_fontsiz_map);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "font_size_message")) {
+    if (iflags.wc_fontsiz_message)
+        Sprintf(buf, "%d", iflags.wc_fontsiz_message);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "font_size_status")) {
+    if (iflags.wc_fontsiz_status)
+        Sprintf(buf, "%d", iflags.wc_fontsiz_status);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "font_size_menu")) {
+    if (iflags.wc_fontsiz_menu)
+        Sprintf(buf, "%d", iflags.wc_fontsiz_menu);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "font_size_text")) {
+    if (iflags.wc_fontsiz_text)
+        Sprintf(buf, "%d", iflags.wc_fontsiz_text);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "fruit"))
+    Sprintf(buf, "%s", pl_fruit);
+else if (!strcmp(optname, "gender"))
+    Sprintf(buf, "%s", rolestring(flags.initgend, genders, adj));
+else if (!strcmp(optname, "horsename"))
+    Sprintf(buf, "%s", horsename[0] ? horsename : none);
+else if (!strcmp(optname, "map_mode")) {
+    i = iflags.wc_map_mode;
+    Sprintf(buf, "%s",
+            (i == MAP_MODE_TILES) ? "tiles"
+            : (i == MAP_MODE_ASCII4x6) ? "ascii4x6"
+              : (i == MAP_MODE_ASCII6x8) ? "ascii6x8"
+                : (i == MAP_MODE_ASCII8x8) ? "ascii8x8"
+                  : (i == MAP_MODE_ASCII16x8) ? "ascii16x8"
+                    : (i == MAP_MODE_ASCII7x12) ? "ascii7x12"
+                      : (i == MAP_MODE_ASCII8x12) ? "ascii8x12"
+                        : (i == MAP_MODE_ASCII16x12) ? "ascii16x12"
+                          : (i == MAP_MODE_ASCII12x16) ? "ascii12x16"
+                            : (i == MAP_MODE_ASCII10x18) ? "ascii10x18"
+                              : (i == MAP_MODE_ASCII_FIT_TO_SCREEN)
+                                ? "fit_to_screen"
+                                : defopt);
+} else if (!strcmp(optname, "menustyle"))
+    Sprintf(buf, "%s", menutype[(int) flags.menu_style]);
+else if (!strcmp(optname, "menu_deselect_all"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_deselect_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_first_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_invert_all"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_headings"))
+    Sprintf(buf, "%s", attr2attrname(iflags.menu_headings));
+else if (!strcmp(optname, "menu_invert_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_last_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_next_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_previous_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_search"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_select_all"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "menu_select_page"))
+    Sprintf(buf, "%s", to_be_done);
+else if (!strcmp(optname, "monsters")) {
+    Sprintf(buf, "%s", to_be_done);
+} else if (!strcmp(optname, "msghistory")) {
+    Sprintf(buf, "%u", iflags.msg_history);
 #ifdef TTY_GRAPHICS
-    } else if (!strcmp(optname, "msg_window")) {
-        Sprintf(buf, "%s", (iflags.prevmsg_window == 's') ? "single"
-                           : (iflags.prevmsg_window == 'c') ? "combination"
-                             : (iflags.prevmsg_window == 'f') ? "full"
-                               : "reversed");
-#endif
-    } else if (!strcmp(optname, "name")) {
-        Sprintf(buf, "%s", plname);
-    } else if (!strcmp(optname, "mouse_support")) {
+} else if (!strcmp(optname, "msg_window")) {
+    Sprintf(buf, "%s", (iflags.prevmsg_window == 's') ? "single"
+                       : (iflags.prevmsg_window == 'c') ? "combination"
+                         : (iflags.prevmsg_window == 'f') ? "full"
+                           : "reversed");
+#endif
+} else if (!strcmp(optname, "name")) {
+    Sprintf(buf, "%s", plname);
+} else if (!strcmp(optname, "mouse_support")) {
 #ifdef WIN32
 #define MOUSEFIX1 ", QuickEdit off"
 #define MOUSEFIX2 ", QuickEdit unchanged"
@@ -5752,329 +5871,334 @@
 #define MOUSEFIX1 ", O/S adjusted"
 #define MOUSEFIX2 ", O/S unchanged"
 #endif
-        static const char *mousemodes[][2] = {
-            { "0=off", "" },
-            { "1=on",  MOUSEFIX1 },
-            { "2=on",  MOUSEFIX2 },
-        };
+    static const char *mousemodes[][2] = {
+        { "0=off", "" },
+        { "1=on",  MOUSEFIX1 },
+        { "2=on",  MOUSEFIX2 },
+    };
 #undef MOUSEFIX1
 #undef MOUSEFIX2
-        int ms = iflags.wc_mouse_support;
+    int ms = iflags.wc_mouse_support;
 
-        if (ms >= 0 && ms <= 2)
-            Sprintf(buf, "%s%s", mousemodes[ms][0], mousemodes[ms][1]);
-    } else if (!strcmp(optname, "number_pad")) {
-        static const char *numpadmodes[] = {
-            "0=off", "1=on", "2=on, MSDOS compatible",
-            "3=on, phone-style layout",
-            "4=on, phone layout, MSDOS compatible",
-            "-1=off, y & z swapped", /*[5]*/
-        };
-        int indx = Cmd.num_pad
-                       ? (Cmd.phone_layout ? (Cmd.pcHack_compat ? 4 : 3)
-                                           : (Cmd.pcHack_compat ? 2 : 1))
-                       : Cmd.swap_yz ? 5 : 0;
-
-        Strcpy(buf, numpadmodes[indx]);
-    } else if (!strcmp(optname, "objects")) {
-        Sprintf(buf, "%s", to_be_done);
-    } else if (!strcmp(optname, "packorder")) {
-        oc_to_str(flags.inv_order, ocl);
-        Sprintf(buf, "%s", ocl);
+    if (ms >= 0 && ms <= 2)
+        Sprintf(buf, "%s%s", mousemodes[ms][0], mousemodes[ms][1]);
+} else if (!strcmp(optname, "number_pad")) {
+    static const char *numpadmodes[] = {
+        "0=off", "1=on", "2=on, MSDOS compatible",
+        "3=on, phone-style layout",
+        "4=on, phone layout, MSDOS compatible",
+        "-1=off, y & z swapped", /*[5]*/
+    };
+    int indx = Cmd.num_pad
+                   ? (Cmd.phone_layout ? (Cmd.pcHack_compat ? 4 : 3)
+                                       : (Cmd.pcHack_compat ? 2 : 1))
+                   : Cmd.swap_yz ? 5 : 0;
+
+    Strcpy(buf, numpadmodes[indx]);
+} else if (!strcmp(optname, "objects")) {
+    Sprintf(buf, "%s", to_be_done);
+} else if (!strcmp(optname, "packorder")) {
+    oc_to_str(flags.inv_order, ocl);
+    Sprintf(buf, "%s", ocl);
 #ifdef CHANGE_COLOR
-    } else if (!strcmp(optname, "palette")) {
-        Sprintf(buf, "%s", get_color_string());
+} else if (!strcmp(optname, "palette")) {
+    Sprintf(buf, "%s", get_color_string());
 #endif
-    } else if (!strcmp(optname, "paranoid_confirmation")) {
-        char tmpbuf[QBUFSZ];
+} else if (!strcmp(optname, "paranoid_confirmation")) {
+    char tmpbuf[QBUFSZ];
 
-        tmpbuf[0] = '\0';
-        for (i = 0; paranoia[i].flagmask != 0; ++i)
-            if (flags.paranoia_bits & paranoia[i].flagmask)
-                Sprintf(eos(tmpbuf), " %s", paranoia[i].argname);
-        Strcpy(buf, tmpbuf[0] ? &tmpbuf[1] : "none");
-    } else if (!strcmp(optname, "petattr")) {
+    tmpbuf[0] = '\0';
+    for (i = 0; paranoia[i].flagmask != 0; ++i)
+        if (flags.paranoia_bits & paranoia[i].flagmask)
+            Sprintf(eos(tmpbuf), " %s", paranoia[i].argname);
+    Strcpy(buf, tmpbuf[0] ? &tmpbuf[1] : "none");
+} else if (!strcmp(optname, "petattr")) {
 #ifdef CURSES_GRAPHICS
-        if (WINDOWPORT("curses")) {
-            char tmpbuf[QBUFSZ];
+    if (WINDOWPORT("curses")) {
+        char tmpbuf[QBUFSZ];
 
-            Strcpy(buf, curses_fmt_attrs(tmpbuf));
-        } else
+        Strcpy(buf, curses_fmt_attrs(tmpbuf));
+    } else
 #endif
-        if (iflags.wc2_petattr != 0)
-            Sprintf(buf, "0x%08x", iflags.wc2_petattr);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "pettype")) {
-        Sprintf(buf, "%s", (preferred_pet == 'c') ? "cat"
-                           : (preferred_pet == 'd') ? "dog"
-                             : (preferred_pet == 'h') ? "horse"
-                               : (preferred_pet == 'n') ? "none"
-                                 : "random");
-    } else if (!strcmp(optname, "pickup_burden")) {
-        Sprintf(buf, "%s", burdentype[flags.pickup_burden]);
-    } else if (!strcmp(optname, "pickup_types")) {
-        oc_to_str(flags.pickup_types, ocl);
-        Sprintf(buf, "%s", ocl[0] ? ocl : "all");
-    } else if (!strcmp(optname, "pile_limit")) {
-        Sprintf(buf, "%d", flags.pile_limit);
-    } else if (!strcmp(optname, "playmode")) {
-        Strcpy(buf, wizard ? "debug" : discover ? "explore" : "normal");
-    } else if (!strcmp(optname, "race")) {
-        Sprintf(buf, "%s", rolestring(flags.initrace, races, noun));
-    } else if (!strcmp(optname, "roguesymset")) {
-        Sprintf(buf, "%s",
-                symset[ROGUESET].name ? symset[ROGUESET].name : "default");
-        if (currentgraphics == ROGUESET && symset[ROGUESET].name)
-            Strcat(buf, ", active");
-    } else if (!strcmp(optname, "role")) {
-        Sprintf(buf, "%s", rolestring(flags.initrole, roles, name.m));
-    } else if (!strcmp(optname, "runmode")) {
-        Sprintf(buf, "%s", runmodes[flags.runmode]);
-    } else if (!strcmp(optname, "whatis_coord")) {
-        Sprintf(buf, "%s",
-                (iflags.getpos_coords == GPCOORDS_MAP) ? "map"
-                : (iflags.getpos_coords == GPCOORDS_COMPASS) ? "compass"
-                : (iflags.getpos_coords == GPCOORDS_COMFULL) ? "full compass"
-                : (iflags.getpos_coords == GPCOORDS_SCREEN) ? "screen"
-                : "none");
-    } else if (!strcmp(optname, "whatis_filter")) {
-        Sprintf(buf, "%s",
-                (iflags.getloc_filter == GFILTER_VIEW) ? "view"
-                : (iflags.getloc_filter == GFILTER_AREA) ? "area"
-                : "none");
-    } else if (!strcmp(optname, "scores")) {
-        Sprintf(buf, "%d top/%d around%s", flags.end_top, flags.end_around,
-                flags.end_own ? "/own" : "");
-    } else if (!strcmp(optname, "scroll_amount")) {
-        if (iflags.wc_scroll_amount)
-            Sprintf(buf, "%d", iflags.wc_scroll_amount);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "scroll_margin")) {
-        if (iflags.wc_scroll_margin)
-            Sprintf(buf, "%d", iflags.wc_scroll_margin);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "sortloot")) {
-        for (i = 0; i < SIZE(sortltype); i++)
-            if (flags.sortloot == sortltype[i][0]) {
-                Strcpy(buf, sortltype[i]);
-                break;
-            }
-    } else if (!strcmp(optname, "player_selection")) {
-        Sprintf(buf, "%s", iflags.wc_player_selection ? "prompts" : "dialog");
+    if (iflags.wc2_petattr != 0)
+        Sprintf(buf, "0x%08x", iflags.wc2_petattr);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "pettype")) {
+    Sprintf(buf, "%s", (preferred_pet == 'c') ? "cat"
+                       : (preferred_pet == 'd') ? "dog"
+                         : (preferred_pet == 'h') ? "horse"
+                           : (preferred_pet == 'n') ? "none"
+                             : "random");
+} else if (!strcmp(optname, "pickup_burden")) {
+    Sprintf(buf, "%s", burdentype[flags.pickup_burden]);
+} else if (!strcmp(optname, "pickup_types")) {
+    oc_to_str(flags.pickup_types, ocl);
+    Sprintf(buf, "%s", ocl[0] ? ocl : "all");
+} else if (!strcmp(optname, "pile_limit")) {
+    Sprintf(buf, "%d", flags.pile_limit);
+} else if (!strcmp(optname, "autosave")) {
+    (iflags.autosave < 0) ? Strcpy(buf, "off")
+    : Sprintf(buf, "%d", iflags.autosave);
+} else if (!strcmp(optname, "playmode")) {
+    Strcpy(buf, wizard ? "debug" : discover ? "explore" : "normal");
+} else if (!strcmp(optname, "race")) {
+    Sprintf(buf, "%s", rolestring(flags.initrace, races, noun));
+} else if (!strcmp(optname, "roguesymset")) {
+    Sprintf(buf, "%s",
+            symset[ROGUESET].name ? symset[ROGUESET].name : "default");
+    if (currentgraphics == ROGUESET && symset[ROGUESET].name)
+        Strcat(buf, ", active");
+} else if (!strcmp(optname, "role")) {
+    Sprintf(buf, "%s", rolestring(flags.initrole, roles, name.m));
+} else if (!strcmp(optname, "runmode")) {
+    Sprintf(buf, "%s", runmodes[flags.runmode]);
+} else if (!strcmp(optname, "voice_command")) {
+    Sprintf(buf, "%s", flags.voice_command);
+} else if (!strcmp(optname, "whatis_coord")) {
+    Sprintf(buf, "%s",
+            (iflags.getpos_coords == GPCOORDS_MAP) ? "map"
+            : (iflags.getpos_coords == GPCOORDS_COMPASS) ? "compass"
+            : (iflags.getpos_coords == GPCOORDS_COMFULL) ? "full compass"
+            : (iflags.getpos_coords == GPCOORDS_SCREEN) ? "screen"
+            : "none");
+} else if (!strcmp(optname, "whatis_filter")) {
+    Sprintf(buf, "%s",
+            (iflags.getloc_filter == GFILTER_VIEW) ? "view"
+            : (iflags.getloc_filter == GFILTER_AREA) ? "area"
+            : "none");
+} else if (!strcmp(optname, "scores")) {
+    Sprintf(buf, "%d top/%d around%s", flags.end_top, flags.end_around,
+            flags.end_own ? "/own" : "");
+} else if (!strcmp(optname, "scroll_amount")) {
+    if (iflags.wc_scroll_amount)
+        Sprintf(buf, "%d", iflags.wc_scroll_amount);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "scroll_margin")) {
+    if (iflags.wc_scroll_margin)
+        Sprintf(buf, "%d", iflags.wc_scroll_margin);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "sortloot")) {
+    for (i = 0; i < SIZE(sortltype); i++)
+        if (flags.sortloot == sortltype[i][0]) {
+            Strcpy(buf, sortltype[i]);
+            break;
+        }
+} else if (!strcmp(optname, "player_selection")) {
+    Sprintf(buf, "%s", iflags.wc_player_selection ? "prompts" : "dialog");
 #ifdef MSDOS
-    } else if (!strcmp(optname, "soundcard")) {
-        Sprintf(buf, "%s", to_be_done);
+} else if (!strcmp(optname, "soundcard")) {
+    Sprintf(buf, "%s", to_be_done);
 #endif
 #ifdef STATUS_HILITES
-    } else if (!strcmp("statushilites", optname)) {
-        if (!iflags.hilite_delta)
-            Strcpy(buf, "0 (off: don't highlight status fields)");
-        else
-            Sprintf(buf, "%ld (on: highlight status for %ld turns)",
-                    iflags.hilite_delta, iflags.hilite_delta);
+} else if (!strcmp("statushilites", optname)) {
+    if (!iflags.hilite_delta)
+        Strcpy(buf, "0 (off: don't highlight status fields)");
+    else
+        Sprintf(buf, "%ld (on: highlight status for %ld turns)",
+                iflags.hilite_delta, iflags.hilite_delta);
 #endif
-    } else if (!strcmp(optname,"statuslines")) {
-        if (wc2_supported(optname))
-            Strcpy(buf, (iflags.wc2_statuslines < 3) ? "2" : "3");
-        /* else default to "unknown" */
-    } else if (!strcmp(optname, "suppress_alert")) {
-        if (flags.suppress_alert == 0L)
-            Strcpy(buf, none);
-        else
-            Sprintf(buf, "%lu.%lu.%lu", FEATURE_NOTICE_VER_MAJ,
-                    FEATURE_NOTICE_VER_MIN, FEATURE_NOTICE_VER_PATCH);
-    } else if (!strcmp(optname, "symset")) {
-        Sprintf(buf, "%s",
-                symset[PRIMARY].name ? symset[PRIMARY].name : "default");
-        if (currentgraphics == PRIMARY && symset[PRIMARY].name)
-            Strcat(buf, ", active");
-    } else if (!strcmp(optname, "term_cols")) {
-        if (iflags.wc2_term_cols)
-            Sprintf(buf, "%d", iflags.wc2_term_cols);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "term_rows")) {
-        if (iflags.wc2_term_rows)
-            Sprintf(buf, "%d", iflags.wc2_term_rows);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "tile_file")) {
-        Sprintf(buf, "%s",
-                iflags.wc_tile_file ? iflags.wc_tile_file : defopt);
-    } else if (!strcmp(optname, "tile_height")) {
-        if (iflags.wc_tile_height)
-            Sprintf(buf, "%d", iflags.wc_tile_height);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "tile_width")) {
-        if (iflags.wc_tile_width)
-            Sprintf(buf, "%d", iflags.wc_tile_width);
-        else
-            Strcpy(buf, defopt);
-    } else if (!strcmp(optname, "traps")) {
-        Sprintf(buf, "%s", to_be_done);
-    } else if (!strcmp(optname, "vary_msgcount")) {
-        if (iflags.wc_vary_msgcount)
-            Sprintf(buf, "%d", iflags.wc_vary_msgcount);
-        else
-            Strcpy(buf, defopt);
+} else if (!strcmp(optname,"statuslines")) {
+    if (wc2_supported(optname))
+        Strcpy(buf, (iflags.wc2_statuslines < 3) ? "2" : "3");
+    /* else default to "unknown" */
+} else if (!strcmp(optname, "suppress_alert")) {
+    if (flags.suppress_alert == 0L)
+        Strcpy(buf, none);
+    else
+        Sprintf(buf, "%lu.%lu.%lu", FEATURE_NOTICE_VER_MAJ,
+                FEATURE_NOTICE_VER_MIN, FEATURE_NOTICE_VER_PATCH);
+} else if (!strcmp(optname, "symset")) {
+    Sprintf(buf, "%s",
+            symset[PRIMARY].name ? symset[PRIMARY].name : "default");
+    if (currentgraphics == PRIMARY && symset[PRIMARY].name)
+        Strcat(buf, ", active");
+} else if (!strcmp(optname, "term_cols")) {
+    if (iflags.wc2_term_cols)
+        Sprintf(buf, "%d", iflags.wc2_term_cols);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "term_rows")) {
+    if (iflags.wc2_term_rows)
+        Sprintf(buf, "%d", iflags.wc2_term_rows);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "tile_file")) {
+    Sprintf(buf, "%s",
+            iflags.wc_tile_file ? iflags.wc_tile_file : defopt);
+} else if (!strcmp(optname, "tile_height")) {
+    if (iflags.wc_tile_height)
+        Sprintf(buf, "%d", iflags.wc_tile_height);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "tile_width")) {
+    if (iflags.wc_tile_width)
+        Sprintf(buf, "%d", iflags.wc_tile_width);
+    else
+        Strcpy(buf, defopt);
+} else if (!strcmp(optname, "traps")) {
+    Sprintf(buf, "%s", to_be_done);
+} else if (!strcmp(optname, "vary_msgcount")) {
+    if (iflags.wc_vary_msgcount)
+        Sprintf(buf, "%d", iflags.wc_vary_msgcount);
+    else
+        Strcpy(buf, defopt);
 #ifdef MSDOS
-    } else if (!strcmp(optname, "video")) {
-        Sprintf(buf, "%s", to_be_done);
+} else if (!strcmp(optname, "video")) {
+    Sprintf(buf, "%s", to_be_done);
 #endif
 #ifdef VIDEOSHADES
-    } else if (!strcmp(optname, "videoshades")) {
-        Sprintf(buf, "%s-%s-%s", shade[0], shade[1], shade[2]);
-    } else if (!strcmp(optname, "videocolors")) {
-        Sprintf(buf, "%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d",
-                ttycolors[CLR_RED], ttycolors[CLR_GREEN],
-                ttycolors[CLR_BROWN], ttycolors[CLR_BLUE],
-                ttycolors[CLR_MAGENTA], ttycolors[CLR_CYAN],
-                ttycolors[CLR_ORANGE], ttycolors[CLR_BRIGHT_GREEN],
-                ttycolors[CLR_YELLOW], ttycolors[CLR_BRIGHT_BLUE],
-                ttycolors[CLR_BRIGHT_MAGENTA], ttycolors[CLR_BRIGHT_CYAN]);
+} else if (!strcmp(optname, "videoshades")) {
+    Sprintf(buf, "%s-%s-%s", shade[0], shade[1], shade[2]);
+} else if (!strcmp(optname, "videocolors")) {
+    Sprintf(buf, "%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d",
+            ttycolors[CLR_RED], ttycolors[CLR_GREEN],
+            ttycolors[CLR_BROWN], ttycolors[CLR_BLUE],
+            ttycolors[CLR_MAGENTA], ttycolors[CLR_CYAN],
+            ttycolors[CLR_ORANGE], ttycolors[CLR_BRIGHT_GREEN],
+            ttycolors[CLR_YELLOW], ttycolors[CLR_BRIGHT_BLUE],
+            ttycolors[CLR_BRIGHT_MAGENTA], ttycolors[CLR_BRIGHT_CYAN]);
 #endif /* VIDEOSHADES */
-    } else if (!strcmp(optname,"windowborders")) {
-        Sprintf(buf, "%s",
-                (iflags.wc2_windowborders == 0) ? "0=off"
-                : (iflags.wc2_windowborders == 1) ? "1=on"
-                  : (iflags.wc2_windowborders == 2) ? "2=auto"
-                    : defopt);
-    } else if (!strcmp(optname, "windowtype")) {
-        Sprintf(buf, "%s", windowprocs.name);
-    } else if (!strcmp(optname, "windowcolors")) {
-        Sprintf(
-            buf, "%s/%s %s/%s %s/%s %s/%s",
-            iflags.wc_foregrnd_menu ? iflags.wc_foregrnd_menu : defbrief,
-            iflags.wc_backgrnd_menu ? iflags.wc_backgrnd_menu : defbrief,
-            iflags.wc_foregrnd_message ? iflags.wc_foregrnd_message
-                                       : defbrief,
-            iflags.wc_backgrnd_message ? iflags.wc_backgrnd_message
-                                       : defbrief,
-            iflags.wc_foregrnd_status ? iflags.wc_foregrnd_status : defbrief,
-            iflags.wc_backgrnd_status ? iflags.wc_backgrnd_status : defbrief,
-            iflags.wc_foregrnd_text ? iflags.wc_foregrnd_text : defbrief,
-            iflags.wc_backgrnd_text ? iflags.wc_backgrnd_text : defbrief);
+} else if (!strcmp(optname,"windowborders")) {
+    Sprintf(buf, "%s",
+            (iflags.wc2_windowborders == 0) ? "0=off"
+            : (iflags.wc2_windowborders == 1) ? "1=on"
+              : (iflags.wc2_windowborders == 2) ? "2=auto"
+                : defopt);
+} else if (!strcmp(optname, "windowtype")) {
+    Sprintf(buf, "%s", windowprocs.name);
+} else if (!strcmp(optname, "windowcolors")) {
+    Sprintf(
+        buf, "%s/%s %s/%s %s/%s %s/%s",
+        iflags.wc_foregrnd_menu ? iflags.wc_foregrnd_menu : defbrief,
+        iflags.wc_backgrnd_menu ? iflags.wc_backgrnd_menu : defbrief,
+        iflags.wc_foregrnd_message ? iflags.wc_foregrnd_message
+                                   : defbrief,
+        iflags.wc_backgrnd_message ? iflags.wc_backgrnd_message
+                                   : defbrief,
+        iflags.wc_foregrnd_status ? iflags.wc_foregrnd_status : defbrief,
+        iflags.wc_backgrnd_status ? iflags.wc_backgrnd_status : defbrief,
+        iflags.wc_foregrnd_text ? iflags.wc_foregrnd_text : defbrief,
+        iflags.wc_backgrnd_text ? iflags.wc_backgrnd_text : defbrief);
 #ifdef PREFIXES_IN_USE
-    } else {
-        for (i = 0; i < PREFIX_COUNT; ++i)
-            if (!strcmp(optname, fqn_prefix_names[i]) && fqn_prefix[i])
-                Sprintf(buf, "%s", fqn_prefix[i]);
+} else {
+    for (i = 0; i < PREFIX_COUNT; ++i)
+        if (!strcmp(optname, fqn_prefix_names[i]) && fqn_prefix[i])
+            Sprintf(buf, "%s", fqn_prefix[i]);
 #endif
-    }
+}
 
-    if (!buf[0])
-        Strcpy(buf, "unknown");
-    return buf;
+if (!buf[0])
+    Strcpy(buf, "unknown");
+return buf;
 }
 
 int
 dotogglepickup()
 {
-    char buf[BUFSZ], ocl[MAXOCLASSES + 1];
+char buf[BUFSZ], ocl[MAXOCLASSES + 1];
 
-    flags.pickup = !flags.pickup;
-    if (flags.pickup) {
-        oc_to_str(flags.pickup_types, ocl);
-        Sprintf(buf, "ON, for %s objects%s", ocl[0] ? ocl : "all",
-                (apelist)
-                    ? ((count_apes() == 1)
-                           ? ", with one exception"
-                           : ", with some exceptions")
-                    : "");
-    } else {
-        Strcpy(buf, "OFF");
-    }
-    pline("Autopickup: %s.", buf);
-    return 0;
+flags.pickup = !flags.pickup;
+if (flags.pickup) {
+    oc_to_str(flags.pickup_types, ocl);
+    Sprintf(buf, "ON, for %s objects%s", ocl[0] ? ocl : "all",
+            (apelist)
+                ? ((count_apes() == 1)
+                       ? ", with one exception"
+                       : ", with some exceptions")
+                : "");
+} else {
+    Strcpy(buf, "OFF");
+}
+pline("Autopickup: %s.", buf);
+return 0;
 }
 
 int
 add_autopickup_exception(mapping)
 const char *mapping;
 {
-    static const char
-        APE_regex_error[] = "regex error in AUTOPICKUP_EXCEPTION",
-        APE_syntax_error[] = "syntax error in AUTOPICKUP_EXCEPTION";
-
-    struct autopickup_exception *ape;
-    char text[256], end;
-    int n;
-    boolean grab = FALSE;
-
-    /* scan length limit used to be 255, but smaller size allows the
-       quoted value to fit within BUFSZ, simplifying formatting elsewhere;
-       this used to ignore the possibility of trailing junk but now checks
-       for it, accepting whitespace but rejecting anything else unless it
-       starts with '#" for a comment */
-    end = '\0';
-    if ((n = sscanf(mapping, "\"<%253[^\"]\" %c", text, &end)) == 1
-        || (n == 2 && end == '#')) {
-        grab = TRUE;
-    } else if ((n = sscanf(mapping, "\">%253[^\"]\" %c", text, &end)) == 1
-               || (n = sscanf(mapping, "\"%253[^\"]\" %c", text, &end)) == 1
-               || (n == 2 && end == '#')) {
-        grab = FALSE;
-    } else {
-        config_error_add("%s", APE_syntax_error);
-        return 0;
-    }
+static const char
+    APE_regex_error[] = "regex error in AUTOPICKUP_EXCEPTION",
+    APE_syntax_error[] = "syntax error in AUTOPICKUP_EXCEPTION";
+
+struct autopickup_exception *ape;
+char text[256], end;
+int n;
+boolean grab = FALSE;
+
+/* scan length limit used to be 255, but smaller size allows the
+   quoted value to fit within BUFSZ, simplifying formatting elsewhere;
+   this used to ignore the possibility of trailing junk but now checks
+   for it, accepting whitespace but rejecting anything else unless it
+   starts with '#" for a comment */
+end = '\0';
+if ((n = sscanf(mapping, "\"<%253[^\"]\" %c", text, &end)) == 1
+    || (n == 2 && end == '#')) {
+    grab = TRUE;
+} else if ((n = sscanf(mapping, "\">%253[^\"]\" %c", text, &end)) == 1
+           || (n = sscanf(mapping, "\"%253[^\"]\" %c", text, &end)) == 1
+           || (n == 2 && end == '#')) {
+    grab = FALSE;
+} else {
+    config_error_add("%s", APE_syntax_error);
+    return 0;
+}
 
-    ape = (struct autopickup_exception *) alloc(sizeof *ape);
-    ape->regex = regex_init();
-    if (!regex_compile(text, ape->regex)) {
-        config_error_add("%s: %s", APE_regex_error,
-                         regex_error_desc(ape->regex));
-        regex_free(ape->regex);
-        free((genericptr_t) ape);
-        return 0;
-    }
+ape = (struct autopickup_exception *) alloc(sizeof *ape);
+ape->regex = regex_init();
+if (!regex_compile(text, ape->regex)) {
+    config_error_add("%s: %s", APE_regex_error,
+                     regex_error_desc(ape->regex));
+    regex_free(ape->regex);
+    free((genericptr_t) ape);
+    return 0;
+}
 
-    ape->pattern = dupstr(text);
-    ape->grab = grab;
-    ape->next = apelist;
-    apelist = ape;
-    return 1;
+ape->pattern = dupstr(text);
+ape->grab = grab;
+ape->next = apelist;
+apelist = ape;
+return 1;
 }
 
 STATIC_OVL void
 remove_autopickup_exception(whichape)
 struct autopickup_exception *whichape;
 {
-    struct autopickup_exception *ape, *freeape, *prev = 0;
+struct autopickup_exception *ape, *freeape, *prev = 0;
 
-    for (ape = apelist; ape;) {
-        if (ape == whichape) {
-            freeape = ape;
-            ape = ape->next;
-            if (prev)
-                prev->next = ape;
-            else
-                apelist = ape;
-            regex_free(freeape->regex);
-            free((genericptr_t) freeape->pattern);
-            free((genericptr_t) freeape);
-        } else {
-            prev = ape;
-            ape = ape->next;
-        }
+for (ape = apelist; ape;) {
+    if (ape == whichape) {
+        freeape = ape;
+        ape = ape->next;
+        if (prev)
+            prev->next = ape;
+        else
+            apelist = ape;
+        regex_free(freeape->regex);
+        free((genericptr_t) freeape->pattern);
+        free((genericptr_t) freeape);
+    } else {
+        prev = ape;
+        ape = ape->next;
     }
 }
+}
 
 void
 free_autopickup_exceptions()
 {
-    struct autopickup_exception *ape = apelist;
+struct autopickup_exception *ape = apelist;
 
-    while ((ape = apelist) != 0) {
-      regex_free(ape->regex);
-      free((genericptr_t) ape->pattern);
-      apelist = ape->next;
-      free((genericptr_t) ape);
-    }
+while ((ape = apelist) != 0) {
+  regex_free(ape->regex);
+  free((genericptr_t) ape->pattern);
+  apelist = ape->next;
+  free((genericptr_t) ape);
+}
 }
 
 /* bundle some common usage into one easy-to-use routine */
@@ -6083,30 +6207,30 @@
 const char *s;
 int which_set;
 {
-    clear_symsetentry(which_set, TRUE);
+clear_symsetentry(which_set, TRUE);
 
-    if (symset[which_set].name)
-        free((genericptr_t) symset[which_set].name);
-    symset[which_set].name = dupstr(s);
+if (symset[which_set].name)
+    free((genericptr_t) symset[which_set].name);
+symset[which_set].name = dupstr(s);
 
-    if (read_sym_file(which_set)) {
-        switch_symbols(TRUE);
-    } else {
-        clear_symsetentry(which_set, TRUE);
-        return 0;
-    }
-    return 1;
+if (read_sym_file(which_set)) {
+    switch_symbols(TRUE);
+} else {
+    clear_symsetentry(which_set, TRUE);
+    return 0;
+}
+return 1;
 }
 
 void
 free_symsets()
 {
-    clear_symsetentry(PRIMARY, TRUE);
-    clear_symsetentry(ROGUESET, TRUE);
+clear_symsetentry(PRIMARY, TRUE);
+clear_symsetentry(ROGUESET, TRUE);
 
-    /* symset_list is cleaned up as soon as it's used, so we shouldn't
-       have to anything about it here */
-    /* assert( symset_list == NULL ); */
+/* symset_list is cleaned up as soon as it's used, so we shouldn't
+   have to anything about it here */
+/* assert( symset_list == NULL ); */
 }
 
 /* Parse the value of a SYMBOLS line from a config file */
@@ -6115,370 +6239,370 @@
 register char *opts;
 int which_set;
 {
-    int val;
-    char *op, *symname, *strval;
-    struct symparse *symp;
-
-    if ((op = index(opts, ',')) != 0) {
-        *op++ = 0;
-        if (!parsesymbols(op, which_set))
-            return FALSE;
-    }
-
-    /* S_sample:string */
-    symname = opts;
-    strval = index(opts, ':');
-    if (!strval)
-        strval = index(opts, '=');
-    if (!strval)
+int val;
+char *op, *symname, *strval;
+struct symparse *symp;
+
+if ((op = index(opts, ',')) != 0) {
+    *op++ = 0;
+    if (!parsesymbols(op, which_set))
         return FALSE;
-    *strval++ = '\0';
+}
 
-    /* strip leading and trailing white space from symname and strval */
-    mungspaces(symname);
-    mungspaces(strval);
+/* S_sample:string */
+symname = opts;
+strval = index(opts, ':');
+if (!strval)
+    strval = index(opts, '=');
+if (!strval)
+    return FALSE;
+*strval++ = '\0';
 
-    symp = match_sym(symname);
-    if (!symp)
-        return FALSE;
+/* strip leading and trailing white space from symname and strval */
+mungspaces(symname);
+mungspaces(strval);
 
-    if (symp->range && symp->range != SYM_CONTROL) {
-        val = sym_val(strval);
-        if (which_set == ROGUESET)
-            update_ov_rogue_symset(symp, val);
-        else
-            update_ov_primary_symset(symp, val);
-    }
-    return TRUE;
+symp = match_sym(symname);
+if (!symp)
+    return FALSE;
+
+if (symp->range && symp->range != SYM_CONTROL) {
+    val = sym_val(strval);
+    if (which_set == ROGUESET)
+        update_ov_rogue_symset(symp, val);
+    else
+        update_ov_primary_symset(symp, val);
+}
+return TRUE;
 }
 
 struct symparse *
 match_sym(buf)
 char *buf;
 {
-    size_t len = strlen(buf);
-    const char *p = index(buf, ':'), *q = index(buf, '=');
-    struct symparse *sp = loadsyms;
-
-    if (!p || (q && q < p))
-        p = q;
-    if (p) {
-        /* note: there will be at most one space before the '='
-           because caller has condensed buf[] with mungspaces() */
-        if (p > buf && p[-1] == ' ')
-            p--;
-        len = (int) (p - buf);
-    }
-    while (sp->range) {
-        if ((len >= strlen(sp->name)) && !strncmpi(buf, sp->name, len))
-            return sp;
-        sp++;
-    }
-    return (struct symparse *) 0;
+size_t len = strlen(buf);
+const char *p = index(buf, ':'), *q = index(buf, '=');
+struct symparse *sp = loadsyms;
+
+if (!p || (q && q < p))
+    p = q;
+if (p) {
+    /* note: there will be at most one space before the '='
+       because caller has condensed buf[] with mungspaces() */
+    if (p > buf && p[-1] == ' ')
+        p--;
+    len = (int) (p - buf);
+}
+while (sp->range) {
+    if ((len >= strlen(sp->name)) && !strncmpi(buf, sp->name, len))
+        return sp;
+    sp++;
+}
+return (struct symparse *) 0;
 }
 
 int
 sym_val(strval)
 const char *strval; /* up to 4*BUFSZ-1 long; only first few chars matter */
 {
-    char buf[QBUFSZ], tmp[QBUFSZ]; /* to hold trucated copy of 'strval' */
+char buf[QBUFSZ], tmp[QBUFSZ]; /* to hold trucated copy of 'strval' */
 
-    buf[0] = '\0';
-    if (!strval[0] || !strval[1]) { /* empty, or single character */
-        /* if single char is space or tab, leave buf[0]=='\0' */
-        if (!isspace((uchar) strval[0]))
-            buf[0] = strval[0];
-    } else if (strval[0] == '\'') { /* single quote */
-        /* simple matching single quote; we know strval[1] isn't '\0' */
-        if (strval[2] == '\'' && !strval[3]) {
-            /* accepts '\' as backslash and ''' as single quote */
-            buf[0] = strval[1];
-
-        /* if backslash, handle single or double quote or second backslash */
-        } else if (strval[1] == '\\' && strval[2] && strval[3] == '\''
-            && index("'\"\\", strval[2]) && !strval[4]) {
-            buf[0] = strval[2];
+buf[0] = '\0';
+if (!strval[0] || !strval[1]) { /* empty, or single character */
+    /* if single char is space or tab, leave buf[0]=='\0' */
+    if (!isspace((uchar) strval[0]))
+        buf[0] = strval[0];
+} else if (strval[0] == '\'') { /* single quote */
+    /* simple matching single quote; we know strval[1] isn't '\0' */
+    if (strval[2] == '\'' && !strval[3]) {
+        /* accepts '\' as backslash and ''' as single quote */
+        buf[0] = strval[1];
+
+    /* if backslash, handle single or double quote or second backslash */
+    } else if (strval[1] == '\\' && strval[2] && strval[3] == '\''
+        && index("'\"\\", strval[2]) && !strval[4]) {
+        buf[0] = strval[2];
 
-        /* not simple quote or basic backslash;
-           strip closing quote and let escapes() deal with it */
-        } else {
-            char *p;
+    /* not simple quote or basic backslash;
+       strip closing quote and let escapes() deal with it */
+    } else {
+        char *p;
 
-            /* +1: skip opening single quote */
-            (void) strncpy(tmp, strval + 1, sizeof tmp - 1);
-            tmp[sizeof tmp - 1] = '\0';
-            if ((p = rindex(tmp, '\'')) != 0) {
-                *p = '\0';
-                escapes(tmp, buf);
-            } /* else buf[0] stays '\0' */
-        }
-    } else { /* not lone char nor single quote */
-        (void) strncpy(tmp, strval, sizeof tmp - 1);
+        /* +1: skip opening single quote */
+        (void) strncpy(tmp, strval + 1, sizeof tmp - 1);
         tmp[sizeof tmp - 1] = '\0';
-        escapes(tmp, buf);
-    }
+        if ((p = rindex(tmp, '\'')) != 0) {
+            *p = '\0';
+            escapes(tmp, buf);
+        } /* else buf[0] stays '\0' */
+    }
+} else { /* not lone char nor single quote */
+    (void) strncpy(tmp, strval, sizeof tmp - 1);
+    tmp[sizeof tmp - 1] = '\0';
+    escapes(tmp, buf);
+}
 
-    return (int) *buf;
+return (int) *buf;
 }
 
 /* data for option_help() */
 static const char *opt_intro[] = {
-    "",
-    "                 NetHack Options Help:", "",
+"",
+"                 NetHack Options Help:", "",
 #define CONFIG_SLOT 3 /* fill in next value at run-time */
-    (char *) 0,
+(char *) 0,
 #if !defined(MICRO) && !defined(MAC)
-    "or use `NETHACKOPTIONS=\"<options>\"' in your environment",
+"or use `NETHACKOPTIONS=\"<options>\"' in your environment",
 #endif
-    "(<options> is a list of options separated by commas)",
+"(<options> is a list of options separated by commas)",
 #ifdef VMS
-    "-- for example, $ DEFINE NETHACKOPTIONS \"noautopickup,fruit:kumquat\"",
+"-- for example, $ DEFINE NETHACKOPTIONS \"noautopickup,fruit:kumquat\"",
 #endif
-    "or press \"O\" while playing and use the menu.",
-    "",
- "Boolean options (which can be negated by prefixing them with '!' or \"no\"):",
-    (char *) 0
+"or press \"O\" while playing and use the menu.",
+"",
+"Boolean options (which can be negated by prefixing them with '!' or \"no\"):",
+(char *) 0
 };
 
 static const char *opt_epilog[] = {
-    "",
-    "Some of the options can be set only before the game is started; those",
-    "items will not be selectable in the 'O' command's menu.",
-    (char *) 0
+"",
+"Some of the options can be set only before the game is started; those",
+"items will not be selectable in the 'O' command's menu.",
+(char *) 0
 };
 
 void
 option_help()
 {
-    char buf[BUFSZ], buf2[BUFSZ];
-    register int i;
-    winid datawin;
-
-    datawin = create_nhwindow(NHW_TEXT);
-    Sprintf(buf, "Set options as OPTIONS=<options> in %s", configfile);
-    opt_intro[CONFIG_SLOT] = (const char *) buf;
-    for (i = 0; opt_intro[i]; i++)
-        putstr(datawin, 0, opt_intro[i]);
+char buf[BUFSZ], buf2[BUFSZ];
+register int i;
+winid datawin;
 
-    /* Boolean options */
-    for (i = 0; boolopt[i].name; i++) {
-        if (boolopt[i].addr) {
-            if (boolopt[i].addr == &iflags.sanity_check && !wizard)
-                continue;
-            if (boolopt[i].addr == &iflags.menu_tab_sep && !wizard)
-                continue;
-            next_opt(datawin, boolopt[i].name);
-        }
+datawin = create_nhwindow(NHW_TEXT);
+Sprintf(buf, "Set options as OPTIONS=<options> in %s", configfile);
+opt_intro[CONFIG_SLOT] = (const char *) buf;
+for (i = 0; opt_intro[i]; i++)
+    putstr(datawin, 0, opt_intro[i]);
+
+/* Boolean options */
+for (i = 0; boolopt[i].name; i++) {
+    if (boolopt[i].addr) {
+        if (boolopt[i].addr == &iflags.sanity_check && !wizard)
+            continue;
+        if (boolopt[i].addr == &iflags.menu_tab_sep && !wizard)
+            continue;
+        next_opt(datawin, boolopt[i].name);
     }
-    next_opt(datawin, "");
+}
+next_opt(datawin, "");
 
-    /* Compound options */
-    putstr(datawin, 0, "Compound options:");
-    for (i = 0; compopt[i].name; i++) {
-        Sprintf(buf2, "`%s'", compopt[i].name);
-        Sprintf(buf, "%-20s - %s%c", buf2, compopt[i].descr,
-                compopt[i + 1].name ? ',' : '.');
-        putstr(datawin, 0, buf);
-    }
+/* Compound options */
+putstr(datawin, 0, "Compound options:");
+for (i = 0; compopt[i].name; i++) {
+    Sprintf(buf2, "`%s'", compopt[i].name);
+    Sprintf(buf, "%-20s - %s%c", buf2, compopt[i].descr,
+            compopt[i + 1].name ? ',' : '.');
+    putstr(datawin, 0, buf);
+}
 
-    for (i = 0; opt_epilog[i]; i++)
-        putstr(datawin, 0, opt_epilog[i]);
+for (i = 0; opt_epilog[i]; i++)
+    putstr(datawin, 0, opt_epilog[i]);
 
-    display_nhwindow(datawin, FALSE);
-    destroy_nhwindow(datawin);
-    return;
+display_nhwindow(datawin, FALSE);
+destroy_nhwindow(datawin);
+return;
 }
 
 /*
- * prints the next boolean option, on the same line if possible, on a new
- * line if not. End with next_opt("").
- */
+* prints the next boolean option, on the same line if possible, on a new
+* line if not. End with next_opt("").
+*/
 void
 next_opt(datawin, str)
 winid datawin;
 const char *str;
 {
-    static char *buf = 0;
-    int i;
-    char *s;
-
-    if (!buf)
-        *(buf = (char *) alloc(BUFSZ)) = '\0';
-
-    if (!*str) {
-        s = eos(buf);
-        if (s > &buf[1] && s[-2] == ',')
-            Strcpy(s - 2, "."); /* replace last ", " */
-        i = COLNO;              /* (greater than COLNO - 2) */
-    } else {
-        i = strlen(buf) + strlen(str) + 2;
-    }
-
-    if (i > COLNO - 2) { /* rule of thumb */
-        putstr(datawin, 0, buf);
-        buf[0] = 0;
-    }
-    if (*str) {
-        Strcat(buf, str);
-        Strcat(buf, ", ");
-    } else {
-        putstr(datawin, 0, str);
-        free((genericptr_t) buf), buf = 0;
-    }
-    return;
+static char *buf = 0;
+int i;
+char *s;
+
+if (!buf)
+    *(buf = (char *) alloc(BUFSZ)) = '\0';
+
+if (!*str) {
+    s = eos(buf);
+    if (s > &buf[1] && s[-2] == ',')
+        Strcpy(s - 2, "."); /* replace last ", " */
+    i = COLNO;              /* (greater than COLNO - 2) */
+} else {
+    i = strlen(buf) + strlen(str) + 2;
+}
+
+if (i > COLNO - 2) { /* rule of thumb */
+    putstr(datawin, 0, buf);
+    buf[0] = 0;
+}
+if (*str) {
+    Strcat(buf, str);
+    Strcat(buf, ", ");
+} else {
+    putstr(datawin, 0, str);
+    free((genericptr_t) buf), buf = 0;
+}
+return;
 }
 
 /* Returns the fid of the fruit type; if that type already exists, it
- * returns the fid of that one; if it does not exist, it adds a new fruit
- * type to the chain and returns the new one.
- * If replace_fruit is sent in, replace the fruit in the chain rather than
- * adding a new entry--for user specified fruits only.
- */
+* returns the fid of that one; if it does not exist, it adds a new fruit
+* type to the chain and returns the new one.
+* If replace_fruit is sent in, replace the fruit in the chain rather than
+* adding a new entry--for user specified fruits only.
+*/
 int
 fruitadd(str, replace_fruit)
 char *str;
 struct fruit *replace_fruit;
 {
-    register int i;
-    register struct fruit *f;
-    int highest_fruit_id = 0, globpfx;
-    char buf[PL_FSIZ], altname[PL_FSIZ];
-    boolean user_specified = (str == pl_fruit);
-    /* if not user-specified, then it's a fruit name for a fruit on
-     * a bones level or from orctown raider's loot...
-     */
+register int i;
+register struct fruit *f;
+int highest_fruit_id = 0, globpfx;
+char buf[PL_FSIZ], altname[PL_FSIZ];
+boolean user_specified = (str == pl_fruit);
+/* if not user-specified, then it's a fruit name for a fruit on
+ * a bones level or from orctown raider's loot...
+ */
 
-    /* Note: every fruit has an id (kept in obj->spe) of at least 1;
-     * 0 is an error.
-     */
-    if (user_specified) {
-        boolean found = FALSE, numeric = FALSE;
+/* Note: every fruit has an id (kept in obj->spe) of at least 1;
+ * 0 is an error.
+ */
+if (user_specified) {
+    boolean found = FALSE, numeric = FALSE;
 
-        /* force fruit to be singular; this handling is not
-           needed--or wanted--for fruits from bones because
-           they already received it in their original game;
-           str==pl_fruit but makesingular() creates a copy
-           so we need to copy that back into pl_fruit */
-        nmcpy(pl_fruit, makesingular(str), PL_FSIZ);
-        /* (assertion doesn't matter; we use 'pl_fruit' from here on out) */
-        /* assert( str == pl_fruit ); */
-
-        /* disallow naming after other foods (since it'd be impossible
-         * to tell the difference); globs might have a size prefix which
-         * needs to be skipped in order to match the object type name
-         */
-        globpfx = (!strncmp(pl_fruit, "small ", 6)
-                   || !strncmp(pl_fruit, "large ", 6)) ? 6
-                  : (!strncmp(pl_fruit, "very large ", 11)) ? 11
-                    : 0;
-        for (i = bases[FOOD_CLASS]; objects[i].oc_class == FOOD_CLASS; i++) {
-            if (!strcmp(OBJ_NAME(objects[i]), pl_fruit)
-                || (globpfx > 0
-                    && !strcmp(OBJ_NAME(objects[i]), &pl_fruit[globpfx]))) {
-                found = TRUE;
-                break;
-            }
+    /* force fruit to be singular; this handling is not
+       needed--or wanted--for fruits from bones because
+       they already received it in their original game;
+       str==pl_fruit but makesingular() creates a copy
+       so we need to copy that back into pl_fruit */
+    nmcpy(pl_fruit, makesingular(str), PL_FSIZ);
+    /* (assertion doesn't matter; we use 'pl_fruit' from here on out) */
+    /* assert( str == pl_fruit ); */
+
+    /* disallow naming after other foods (since it'd be impossible
+     * to tell the difference); globs might have a size prefix which
+     * needs to be skipped in order to match the object type name
+     */
+    globpfx = (!strncmp(pl_fruit, "small ", 6)
+               || !strncmp(pl_fruit, "large ", 6)) ? 6
+              : (!strncmp(pl_fruit, "very large ", 11)) ? 11
+                : 0;
+    for (i = bases[FOOD_CLASS]; objects[i].oc_class == FOOD_CLASS; i++) {
+        if (!strcmp(OBJ_NAME(objects[i]), pl_fruit)
+            || (globpfx > 0
+                && !strcmp(OBJ_NAME(objects[i]), &pl_fruit[globpfx]))) {
+            found = TRUE;
+            break;
         }
-        if (!found) {
-            char *c;
+    }
+    if (!found) {
+        char *c;
 
-            for (c = pl_fruit; *c >= '0' && *c <= '9'; c++)
-                continue;
-            if (!*c || isspace((uchar) *c))
-                numeric = TRUE;
-        }
-        if (found || numeric
-            /* these checks for applying food attributes to actual items
-               are case sensitive; "glob of foo" is caught by 'found'
-               if 'foo' is a valid glob; when not valid, allow it as-is */
-            || !strncmp(pl_fruit, "cursed ", 7)
-            || !strncmp(pl_fruit, "uncursed ", 9)
-            || !strncmp(pl_fruit, "blessed ", 8)
-            || !strncmp(pl_fruit, "partly eaten ", 13)
-            || (!strncmp(pl_fruit, "tin of ", 7)
-                && (!strcmp(pl_fruit + 7, "spinach")
-                    || name_to_mon(pl_fruit + 7) >= LOW_PM))
-            || !strcmp(pl_fruit, "empty tin")
-            || (!strcmp(pl_fruit, "glob")
-                || (globpfx > 0 && !strcmp("glob", &pl_fruit[globpfx])))
-            || ((str_end_is(pl_fruit, " corpse")
-                 || str_end_is(pl_fruit, " egg"))
-                && name_to_mon(pl_fruit) >= LOW_PM)) {
-            Strcpy(buf, pl_fruit);
-            Strcpy(pl_fruit, "candied ");
-            nmcpy(pl_fruit + 8, buf, PL_FSIZ - 8);
-        }
-        *altname = '\0';
-        /* This flag indicates that a fruit has been made since the
-         * last time the user set the fruit.  If it hasn't, we can
-         * safely overwrite the current fruit, preventing the user from
-         * setting many fruits in a row and overflowing.
-         * Possible expansion: check for specific fruit IDs, not for
-         * any fruit.
-         */
-        flags.made_fruit = FALSE;
-        if (replace_fruit) {
-            /* replace_fruit is already part of the fruit chain;
-               update it in place rather than looking it up again */
-            f = replace_fruit;
-            copynchars(f->fname, pl_fruit, PL_FSIZ - 1);
-            goto nonew;
-        }
-    } else {
-        /* not user_supplied, so assumed to be from bones (or orc gang) */
-        copynchars(altname, str, PL_FSIZ - 1);
-        sanitize_name(altname);
-        flags.made_fruit = TRUE; /* for safety.  Any fruit name added from a
-                                  * bones level should exist anyway. */
+        for (c = pl_fruit; *c >= '0' && *c <= '9'; c++)
+            continue;
+        if (!*c || isspace((uchar) *c))
+            numeric = TRUE;
     }
-    f = fruit_from_name(*altname ? altname : str, FALSE, &highest_fruit_id);
-    if (f)
+    if (found || numeric
+        /* these checks for applying food attributes to actual items
+           are case sensitive; "glob of foo" is caught by 'found'
+           if 'foo' is a valid glob; when not valid, allow it as-is */
+        || !strncmp(pl_fruit, "cursed ", 7)
+        || !strncmp(pl_fruit, "uncursed ", 9)
+        || !strncmp(pl_fruit, "blessed ", 8)
+        || !strncmp(pl_fruit, "partly eaten ", 13)
+        || (!strncmp(pl_fruit, "tin of ", 7)
+            && (!strcmp(pl_fruit + 7, "spinach")
+                || name_to_mon(pl_fruit + 7) >= LOW_PM))
+        || !strcmp(pl_fruit, "empty tin")
+        || (!strcmp(pl_fruit, "glob")
+            || (globpfx > 0 && !strcmp("glob", &pl_fruit[globpfx])))
+        || ((str_end_is(pl_fruit, " corpse")
+             || str_end_is(pl_fruit, " egg"))
+            && name_to_mon(pl_fruit) >= LOW_PM)) {
+        Strcpy(buf, pl_fruit);
+        Strcpy(pl_fruit, "candied ");
+        nmcpy(pl_fruit + 8, buf, PL_FSIZ - 8);
+    }
+    *altname = '\0';
+    /* This flag indicates that a fruit has been made since the
+     * last time the user set the fruit.  If it hasn't, we can
+     * safely overwrite the current fruit, preventing the user from
+     * setting many fruits in a row and overflowing.
+     * Possible expansion: check for specific fruit IDs, not for
+     * any fruit.
+     */
+    flags.made_fruit = FALSE;
+    if (replace_fruit) {
+        /* replace_fruit is already part of the fruit chain;
+           update it in place rather than looking it up again */
+        f = replace_fruit;
+        copynchars(f->fname, pl_fruit, PL_FSIZ - 1);
         goto nonew;
-
-    /* Maximum number of named fruits is 127, even if obj->spe can
-       handle bigger values.  If adding another fruit would overflow,
-       use a random fruit instead... we've got a lot to choose from.
-       current_fruit remains as is. */
-    if (highest_fruit_id >= 127)
-        return rnd(127);
-
-    f = newfruit();
-    (void) memset((genericptr_t) f, 0, sizeof (struct fruit));
-    copynchars(f->fname, *altname ? altname : str, PL_FSIZ - 1);
-    f->fid = ++highest_fruit_id;
-    /* we used to go out of our way to add it at the end of the list,
-       but the order is arbitrary so use simpler insertion at start */
-    f->nextf = ffruit;
-    ffruit = f;
- nonew:
-    if (user_specified)
-        context.current_fruit = f->fid;
-    return f->fid;
+    }
+} else {
+    /* not user_supplied, so assumed to be from bones (or orc gang) */
+    copynchars(altname, str, PL_FSIZ - 1);
+    sanitize_name(altname);
+    flags.made_fruit = TRUE; /* for safety.  Any fruit name added from a
+                              * bones level should exist anyway. */
+}
+f = fruit_from_name(*altname ? altname : str, FALSE, &highest_fruit_id);
+if (f)
+    goto nonew;
+
+/* Maximum number of named fruits is 127, even if obj->spe can
+   handle bigger values.  If adding another fruit would overflow,
+   use a random fruit instead... we've got a lot to choose from.
+   current_fruit remains as is. */
+if (highest_fruit_id >= 127)
+    return rnd(127);
+
+f = newfruit();
+(void) memset((genericptr_t) f, 0, sizeof (struct fruit));
+copynchars(f->fname, *altname ? altname : str, PL_FSIZ - 1);
+f->fid = ++highest_fruit_id;
+/* we used to go out of our way to add it at the end of the list,
+   but the order is arbitrary so use simpler insertion at start */
+f->nextf = ffruit;
+ffruit = f;
+nonew:
+if (user_specified)
+    context.current_fruit = f->fid;
+return f->fid;
 }
 
 /*
- * This is a somewhat generic menu for taking a list of NetHack style
- * class choices and presenting them via a description
- * rather than the traditional NetHack characters.
- * (Benefits users whose first exposure to NetHack is via tiles).
- *
- * prompt
- *           The title at the top of the menu.
- *
- * category: 0 = monster class
- *           1 = object  class
- *
- * way
- *           FALSE = PICK_ONE, TRUE = PICK_ANY
- *
- * class_list
- *           a null terminated string containing the list of choices.
- *
- * class_selection
- *           a null terminated string containing the selected characters.
- *
- * Returns number selected.
- */
+* This is a somewhat generic menu for taking a list of NetHack style
+* class choices and presenting them via a description
+* rather than the traditional NetHack characters.
+* (Benefits users whose first exposure to NetHack is via tiles).
+*
+* prompt
+*           The title at the top of the menu.
+*
+* category: 0 = monster class
+*           1 = object  class
+*
+* way
+*           FALSE = PICK_ONE, TRUE = PICK_ANY
+*
+* class_list
+*           a null terminated string containing the list of choices.
+*
+* class_selection
+*           a null terminated string containing the selected characters.
+*
+* Returns number selected.
+*/
 int
 choose_classes_menu(prompt, category, way, class_list, class_select)
 const char *prompt;
@@ -6487,108 +6611,108 @@
 char *class_list;
 char *class_select;
 {
-    menu_item *pick_list = (menu_item *) 0;
-    winid win;
-    anything any;
-    char buf[BUFSZ];
-    int i, n;
-    int ret;
-    int next_accelerator, accelerator;
+menu_item *pick_list = (menu_item *) 0;
+winid win;
+anything any;
+char buf[BUFSZ];
+int i, n;
+int ret;
+int next_accelerator, accelerator;
 
-    if (class_list == (char *) 0 || class_select == (char *) 0)
-        return 0;
-    accelerator = 0;
-    next_accelerator = 'a';
-    any = zeroany;
-    win = create_nhwindow(NHW_MENU);
-    start_menu(win);
-    while (*class_list) {
-        const char *text;
-        boolean selected;
-
-        text = (char *) 0;
-        selected = FALSE;
-        switch (category) {
-        case 0:
-            text = def_monsyms[def_char_to_monclass(*class_list)].explain;
-            accelerator = *class_list;
-            Sprintf(buf, "%s", text);
-            break;
-        case 1:
-            text = def_oc_syms[def_char_to_objclass(*class_list)].explain;
-            accelerator = next_accelerator;
-            Sprintf(buf, "%c  %s", *class_list, text);
+if (class_list == (char *) 0 || class_select == (char *) 0)
+    return 0;
+accelerator = 0;
+next_accelerator = 'a';
+any = zeroany;
+win = create_nhwindow(NHW_MENU);
+start_menu(win);
+while (*class_list) {
+    const char *text;
+    boolean selected;
+
+    text = (char *) 0;
+    selected = FALSE;
+    switch (category) {
+    case 0:
+        text = def_monsyms[def_char_to_monclass(*class_list)].explain;
+        accelerator = *class_list;
+        Sprintf(buf, "%s", text);
+        break;
+    case 1:
+        text = def_oc_syms[def_char_to_objclass(*class_list)].explain;
+        accelerator = next_accelerator;
+        Sprintf(buf, "%c  %s", *class_list, text);
+        break;
+    default:
+        impossible("choose_classes_menu: invalid category %d", category);
+    }
+    if (way && *class_select) { /* Selections there already */
+        if (index(class_select, *class_list)) {
+            selected = TRUE;
+        }
+    }
+    any.a_int = *class_list;
+    add_menu(win, NO_GLYPH, &any, accelerator, category ? *class_list : 0,
+             ATR_NONE, buf, selected);
+    ++class_list;
+    if (category > 0) {
+        ++next_accelerator;
+        if (next_accelerator == ('z' + 1))
+            next_accelerator = 'A';
+        if (next_accelerator == ('Z' + 1))
             break;
-        default:
-            impossible("choose_classes_menu: invalid category %d", category);
-        }
-        if (way && *class_select) { /* Selections there already */
-            if (index(class_select, *class_list)) {
-                selected = TRUE;
-            }
-        }
-        any.a_int = *class_list;
-        add_menu(win, NO_GLYPH, &any, accelerator, category ? *class_list : 0,
-                 ATR_NONE, buf, selected);
-        ++class_list;
-        if (category > 0) {
-            ++next_accelerator;
-            if (next_accelerator == ('z' + 1))
-                next_accelerator = 'A';
-            if (next_accelerator == ('Z' + 1))
-                break;
-        }
     }
-    if (category == 1 && next_accelerator <= 'z') {
-        /* for objects, add "A - ' '  all classes", after a separator */
-        any = zeroany;
-        add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
-        any.a_int = (int) ' ';
-        Sprintf(buf, "%c  %s", (char) any.a_int, "all classes of objects");
-        /* we won't preselect this even if the incoming list is empty;
-           having it selected means that it would have to be explicitly
-           de-selected in order to select anything else */
-        add_menu(win, NO_GLYPH, &any, 'A', 0, ATR_NONE, buf, MENU_UNSELECTED);
-    }
-    end_menu(win, prompt);
-    n = select_menu(win, way ? PICK_ANY : PICK_ONE, &pick_list);
-    destroy_nhwindow(win);
-    if (n > 0) {
-        if (category == 1) {
-            /* for object classes, first check for 'all'; it means 'use
-               a blank list' rather than 'collect every possible choice' */
-            for (i = 0; i < n; ++i)
-                if (pick_list[i].item.a_int == ' ') {
-                    pick_list[0].item.a_int = ' ';
-                    n = 1; /* return 1; also an implicit 'break;' */
-                }
-        }
+}
+if (category == 1 && next_accelerator <= 'z') {
+    /* for objects, add "A - ' '  all classes", after a separator */
+    any = zeroany;
+    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+    any.a_int = (int) ' ';
+    Sprintf(buf, "%c  %s", (char) any.a_int, "all classes of objects");
+    /* we won't preselect this even if the incoming list is empty;
+       having it selected means that it would have to be explicitly
+       de-selected in order to select anything else */
+    add_menu(win, NO_GLYPH, &any, 'A', 0, ATR_NONE, buf, MENU_UNSELECTED);
+}
+end_menu(win, prompt);
+n = select_menu(win, way ? PICK_ANY : PICK_ONE, &pick_list);
+destroy_nhwindow(win);
+if (n > 0) {
+    if (category == 1) {
+        /* for object classes, first check for 'all'; it means 'use
+           a blank list' rather than 'collect every possible choice' */
         for (i = 0; i < n; ++i)
-            *class_select++ = (char) pick_list[i].item.a_int;
-        free((genericptr_t) pick_list);
-        ret = n;
-    } else if (n == -1) {
-        class_select = eos(class_select);
-        ret = -1;
-    } else
-        ret = 0;
-    *class_select = '\0';
-    return ret;
+            if (pick_list[i].item.a_int == ' ') {
+                pick_list[0].item.a_int = ' ';
+                n = 1; /* return 1; also an implicit 'break;' */
+            }
+    }
+    for (i = 0; i < n; ++i)
+        *class_select++ = (char) pick_list[i].item.a_int;
+    free((genericptr_t) pick_list);
+    ret = n;
+} else if (n == -1) {
+    class_select = eos(class_select);
+    ret = -1;
+} else
+    ret = 0;
+*class_select = '\0';
+return ret;
 }
 
 static struct wc_Opt wc_options[] = {
-    { "ascii_map", WC_ASCII_MAP },
-    { "color", WC_COLOR },
-    { "eight_bit_tty", WC_EIGHT_BIT_IN },
-    { "hilite_pet", WC_HILITE_PET },
-    { "popup_dialog", WC_POPUP_DIALOG },
-    { "player_selection", WC_PLAYER_SELECTION },
-    { "preload_tiles", WC_PRELOAD_TILES },
-    { "tiled_map", WC_TILED_MAP },
-    { "tile_file", WC_TILE_FILE },
-    { "tile_width", WC_TILE_WIDTH },
-    { "tile_height", WC_TILE_HEIGHT },
-    { "use_inverse", WC_INVERSE },
+{ "ascii_map", WC_ASCII_MAP },
+{ "color", WC_COLOR },
+{ "eight_bit_tty", WC_EIGHT_BIT_IN },
+{ "hilite_pet", WC_HILITE_PET },
+{ "popup_dialog", WC_POPUP_DIALOG },
+{ "player_selection", WC_PLAYER_SELECTION },
+{ "preload_tiles", WC_PRELOAD_TILES },
+{ "tiled_map", WC_TILED_MAP },
+{ "tile_file", WC_TILE_FILE },
+{ "tile_width", WC_TILE_WIDTH },
+{ "tile_height", WC_TILE_HEIGHT },
+{ "use_inverse", WC_INVERSE },
     { "align_message", WC_ALIGN_MESSAGE },
     { "align_status", WC_ALIGN_STATUS },
     { "font_map", WC_FONT_MAP },
@@ -6933,4 +7057,120 @@
 
 #endif /* OPTION_LISTS_ONLY */
 
+#ifdef VOICE_ENABLED
+int add_voice_exception(const char *pattern) {
+    struct voice_exception *newve = (struct voice_exception *) alloc(sizeof *newve);
+    newve->pattern = dupstr(pattern);
+    newve->flags = 0; // Or set some initial flags if needed
+    newve->next = voicelist;
+    voicelist = newve;
+    return 0; // Return success or error code
+}
+
+void free_voice_exceptions() {
+    struct voice_exception *ve, *nextve;
+    for (ve = voicelist; ve; ve = nextve) {
+        nextve = ve->next;
+        free((genericptr_t) ve->pattern);
+        free((genericptr_t) ve);
+    }
+    voicelist = (struct voice_exception *)0;
+}
+
+struct voice_exception *check_voice_exceptions(const char *text) {
+    struct voice_exception *ve;
+    for (ve = voicelist; ve; ve = ve->next) {
+        if (pmatch(ve->pattern, text)) {
+            return ve; // Found a match
+        }
+    }
+    return (struct voice_exception *)0; // No match found
+}
+
+int add_voice_force(const char *pattern) {
+    struct voice_force *newvf;
+    char *sep;
+    char *match_pattern = NULL;
+    char *speak_text = NULL;
+    regex_t regex;
+    int reti;
+
+    newvf = (struct voice_force *)alloc(sizeof *newvf);
+    if (!newvf) {
+        config_error_add("Memory allocation failed for VOICE_FORCE");
+        return -1;
+    }
+
+    sep = strstr(pattern, "=>");
+    if (sep) {
+        size_t match_len = sep - pattern;
+        match_pattern = (char *)alloc(match_len + 1);
+        if (!match_pattern) {
+            config_error_add("Memory allocation failed for VOICE_FORCE pattern");
+            free(newvf);
+            return -1;
+        }
+        strncpy(match_pattern, pattern, match_len);
+        match_pattern[match_len] = '\0';
+        speak_text = dupstr(sep + 2); // Skip "=>"
+        if (!speak_text) {
+            config_error_add("Memory allocation failed for VOICE_FORCE speak_text");
+            free(match_pattern);
+            free(newvf);
+            return -1;
+        }
+    } else {
+        match_pattern = dupstr(pattern);
+        if (!match_pattern) {
+            config_error_add("Memory allocation failed for VOICE_FORCE pattern");
+            free(newvf);
+            return -1;
+        }
+        speak_text = NULL; // NULL means use full message
+    }
+
+    // Validate the regex pattern
+    reti = regcomp(&regex, match_pattern, REG_EXTENDED);
+    if (reti) {
+        char errbuf[BUFSZ];
+        regerror(reti, &regex, errbuf, sizeof(errbuf));
+        config_error_add("Could not compile VOICE_FORCE regex '%s': %s", match_pattern, errbuf);
+        free(match_pattern);
+        free(speak_text);
+        free(newvf);
+        regfree(&regex);
+        return -1;
+    }
+    regfree(&regex);
+
+    newvf->pattern = match_pattern;
+    newvf->speak_text = speak_text;
+    newvf->flags = 0;
+    newvf->next = forcelist;
+    forcelist = newvf;
+    return 0;
+}
+
+void free_voice_forces() {
+    struct voice_force *vf, *nextvf;
+    for (vf = forcelist; vf; vf = nextvf) {
+        nextvf = vf->next;
+        free((genericptr_t) vf->pattern);
+        if (vf->speak_text) free((genericptr_t) vf->speak_text);
+        free((genericptr_t) vf);
+    }
+    forcelist = (struct voice_force *)0;
+}
+
+struct voice_force *check_voice_forces(const char *text) {
+    struct voice_force *vf;
+    for (vf = forcelist; vf; vf = vf->next) {
+        if (pmatch(vf->pattern, text)) {
+            return vf;
+        }
+    }
+    return (struct voice_force *)0;
+}
+#endif /* VOICE_ENABLED */
+
 /*options.c*/
